# Rust 宏详解

## 📚 什么是宏？

**宏**（Macro）是 Rust 中的元编程工具，允许你编写能够生成其他代码的代码。宏在编译时展开，生成的代码会被插入到源代码中。

### 宏 vs 函数

| 特性 | 函数 | 宏 |
|------|------|-----|
| **参数数量** | 固定 | 可变 |
| **参数类型** | 必须指定 | 可以是任意类型 |
| **执行时机** | 运行时 | 编译时 |
| **操作对象** | 值 | 代码（AST） |
| **定义位置** | 任意位置 | 必须在使用前定义 |
| **调用方式** | `func()` | `macro!()` |

### 宏的优势

- ✅ **减少重复代码** - 自动生成模板代码
- ✅ **编译时计算** - 将计算移到编译期，减少运行时开销
- ✅ **创建 DSL** - 定义领域特定语言
- ✅ **可变参数** - 接受任意数量的参数
- ✅ **代码生成** - 根据输入自动生成代码

### 宏的劣势

- ❌ **复杂性高** - 难以编写和理解
- ❌ **编译时间长** - 增加编译时间
- ❌ **错误信息难懂** - 错误提示不够清晰
- ❌ **调试困难** - 难以调试宏展开后的代码

---

## 🎯 Rust 宏的分类

Rust 中有两大类宏：

### 1️⃣ 声明宏（Declarative Macros）

使用 `macro_rules!` 定义，通过模式匹配生成代码。

### 2️⃣ 过程宏（Procedural Macros）

操作 AST（抽象语法树），更强大但更复杂。分为三种：
- **派生宏**（Derive Macros）
- **属性宏**（Attribute Macros）
- **函数式宏**（Function-like Macros）

---

## 📝 声明宏（Declarative Macros）

### 基本语法

```rust
macro_rules! macro_name {
    (pattern1) => {
        // 生成的代码
    };
    (pattern2) => {
        // 生成的代码
    };
}
```

### 示例 1：简单的打印宏

```rust
macro_rules! say_hello {
    () => {
        println!("Hello, World!");
    };
}

fn main() {
    say_hello!(); // 输出：Hello, World!
}
```

### 示例 2：带参数的宏

```rust
macro_rules! greet {
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}

fn main() {
    greet!("Alice"); // 输出：Hello, Alice!
}
```

### 示例 3：多个模式

```rust
macro_rules! calculate {
    // 加法
    ($a:expr + $b:expr) => {
        $a + $b
    };
    // 乘法
    ($a:expr * $b:expr) => {
        $a * $b
    };
}

fn main() {
    let sum = calculate!(5 + 3);      // 8
    let product = calculate!(5 * 3);  // 15
}
```

### 示例 4：可变参数（重复模式）

```rust
macro_rules! vec_of_strings {
    ($($x:expr),*) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x.to_string());
            )*
            temp_vec
        }
    };
}

fn main() {
    let v = vec_of_strings!("hello", "world", "rust");
    println!("{:?}", v); // ["hello", "world", "rust"]
}
```

### 模式匹配类型

| 类型 | 说明 | 示例 |
|------|------|------|
| `expr` | 表达式 | `$x:expr` |
| `ident` | 标识符 | `$name:ident` |
| `ty` | 类型 | `$t:ty` |
| `pat` | 模式 | `$p:pat` |
| `stmt` | 语句 | `$s:stmt` |
| `block` | 代码块 | `$b:block` |
| `item` | 项（函数、结构体等） | `$i:item` |
| `tt` | Token 树 | `$t:tt` |

### 重复模式语法

| 语法 | 说明 |
|------|------|
| `$(...)*` | 零次或多次 |
| `$(...)+` | 一次或多次 |
| `$(...)?` | 零次或一次 |

---

## 🔧 过程宏（Procedural Macros）

过程宏必须定义在单独的 crate 中，并在 `Cargo.toml` 中声明：

```toml
[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
proc-macro2 = "1.0"
```

### 1️⃣ 派生宏（Derive Macros）

**用途**：为类型自动实现 trait

#### 示例：自定义 Debug

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyDebug)]
pub fn my_debug_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    let expanded = quote! {
        impl std::fmt::Debug for #name {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "MyDebug: {}", stringify!(#name))
            }
        }
    };

    TokenStream::from(expanded)
}
```

**使用**：

```rust
#[derive(MyDebug)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let p = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    println!("{:?}", p); // MyDebug: Person
}
```

### 2️⃣ 属性宏（Attribute Macros）

**用途**：为函数、结构体等添加自定义属性

#### 示例：计时器

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn timing(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_sig = &input.sig;

    let expanded = quote! {
        #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let duration = start.elapsed();
            println!("{} took {:?}", stringify!(#fn_name), duration);
            result
        }
    };

    TokenStream::from(expanded)
}
```

**使用**：

```rust
#[timing]
fn slow_function() {
    std::thread::sleep(std::time::Duration::from_secs(1));
}

fn main() {
    slow_function(); // slow_function took 1.00s
}
```

### 3️⃣ 函数式宏（Function-like Macros）

**用途**：类似函数调用的宏

#### 示例：SQL 查询

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let sql_query = input.to_string();
    println!("SQL Query: {}", sql_query);
    
    // 这里可以进行 SQL 验证
    
    format!("String::from({})", sql_query)
        .parse()
        .unwrap()
}
```

**使用**：

```rust
fn main() {
    let query = sql!("SELECT * FROM users WHERE id = 1");
    println!("{}", query);
}
```

---

## 💡 使用宏的最佳时机

### ✅ 应该使用宏的场景

#### 1. 减少重复代码

```rust
macro_rules! impl_add {
    ($($t:ty),*) => {
        $(
            impl Add for $t {
                type Output = $t;
                fn add(self, other: $t) -> $t {
                    self + other
                }
            }
        )*
    };
}

impl_add!(i8, i16, i32, i64);
```

#### 2. 编译时验证

```rust
// 在编译时验证 SQL 查询
let users = sqlx::query!("SELECT * FROM users WHERE id = ?", user_id)
    .fetch_all(&pool)
    .await?;
```

#### 3. 创建 DSL

```rust
// Rocket 框架的路由定义
#[get("/hello/<name>")]
fn hello(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

#### 4. 自动实现 trait

```rust
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct User {
    name: String,
    age: u32,
}
```

#### 5. 可变参数

```rust
println!("Hello, {}! You are {} years old.", name, age);
vec![1, 2, 3, 4, 5];
```

### ❌ 不应该使用宏的场景

#### 1. 简单的代码复用

```rust
// ❌ 不要用宏
macro_rules! add {
    ($a:expr, $b:expr) => {
        $a + $b
    };
}

// ✅ 使用函数
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

#### 2. 类型转换

```rust
// ❌ 不要用宏
macro_rules! to_string {
    ($x:expr) => {
        $x.to_string()
    };
}

// ✅ 直接调用方法
let s = value.to_string();
```

#### 3. 简单的条件逻辑

```rust
// ❌ 不要用宏
macro_rules! max {
    ($a:expr, $b:expr) => {
        if $a > $b { $a } else { $b }
    };
}

// ✅ 使用函数
fn max<T: Ord>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
```

---

## 🎨 实战示例

### 示例 1：JSON 构建器

```rust
macro_rules! json {
    (null) => {
        serde_json::Value::Null
    };
    ([$($elem:tt),*]) => {
        serde_json::Value::Array(vec![$(json!($elem)),*])
    };
    ({$($key:tt : $value:tt),*}) => {
        serde_json::Value::Object({
            let mut map = serde_json::Map::new();
            $(
                map.insert($key.to_string(), json!($value));
            )*
            map
        })
    };
    ($other:tt) => {
        serde_json::to_value($other).unwrap()
    };
}

fn main() {
    let data = json!({
        "name": "Alice",
        "age": 30,
        "hobbies": ["reading", "coding"]
    });
}
```

### 示例 2：单元测试辅助

```rust
macro_rules! test_case {
    ($name:ident: $input:expr => $expected:expr) => {
        #[test]
        fn $name() {
            assert_eq!(my_function($input), $expected);
        }
    };
}

test_case!(test_zero: 0 => 0);
test_case!(test_one: 1 => 1);
test_case!(test_two: 2 => 4);
```

### 示例 3：错误处理

```rust
macro_rules! try_opt {
    ($expr:expr) => {
        match $expr {
            Some(val) => val,
            None => return None,
        }
    };
}

fn parse_number(s: &str) -> Option<i32> {
    let trimmed = try_opt!(s.trim().parse().ok());
    Some(trimmed * 2)
}
```

---

## 📊 常见宏示例

### 标准库宏

| 宏 | 用途 |
|-----|------|
| `println!` | 格式化输出 |
| `vec!` | 创建 Vec |
| `format!` | 格式化字符串 |
| `panic!` | 触发 panic |
| `assert!` | 断言 |
| `dbg!` | 调试输出 |
| `todo!` | 标记未完成代码 |
| `unimplemented!` | 标记未实现代码 |

### 第三方库宏

| 库 | 宏 | 用途 |
|----|-----|------|
| Serde | `#[derive(Serialize, Deserialize)]` | 序列化/反序列化 |
| Rocket | `#[get("/path")]` | 路由定义 |
| SQLx | `query!` | SQL 查询 |
| Tokio | `#[tokio::main]` | 异步运行时 |

---

## 🛠️ 最佳实践

### 1. 保持简单

```rust
// ✅ 好：简单清晰
macro_rules! log_error {
    ($msg:expr) => {
        eprintln!("[ERROR] {}", $msg);
    };
}

// ❌ 差：过于复杂
macro_rules! complex_macro {
    // 太多模式匹配...
}
```

### 2. 提供清晰的文档

```rust
/// 创建一个包含指定元素的 Vec
///
/// # 示例
///
/// ```
/// let v = my_vec![1, 2, 3];
/// assert_eq!(v, vec![1, 2, 3]);
/// ```
macro_rules! my_vec {
    ($($x:expr),*) => {
        vec![$($x),*]
    };
}
```

### 3. 使用 `#[macro_export]`

```rust
#[macro_export]
macro_rules! my_macro {
    () => {
        // ...
    };
}
```

### 4. 处理错误

```rust
macro_rules! safe_divide {
    ($a:expr, $b:expr) => {
        if $b == 0 {
            compile_error!("Division by zero!");
        } else {
            $a / $b
        }
    };
}
```

### 5. 测试宏

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_my_macro() {
        let result = my_macro!(1, 2, 3);
        assert_eq!(result, vec![1, 2, 3]);
    }
}
```

---

## 🐛 常见陷阱

### 1. 卫生性问题

```rust
// ❌ 可能导致命名冲突
macro_rules! bad_macro {
    () => {
        let x = 42;
    };
}

// ✅ 使用唯一名称
macro_rules! good_macro {
    () => {
        let _macro_temp_x = 42;
    };
}
```

### 2. 重复展开

```rust
// ❌ 表达式会被计算多次
macro_rules! bad_max {
    ($a:expr, $b:expr) => {
        if $a > $b { $a } else { $b }
    };
}

// 如果调用 bad_max!(expensive_call(), other_call())
// expensive_call() 可能被调用两次！

// ✅ 使用临时变量
macro_rules! good_max {
    ($a:expr, $b:expr) => {{
        let a = $a;
        let b = $b;
        if a > b { a } else { b }
    }};
}
```

### 3. 类型推断问题

```rust
// ❌ 可能导致类型推断失败
macro_rules! create_vec {
    () => {
        Vec::new()
    };
}

// ✅ 明确类型
macro_rules! create_vec {
    ($t:ty) => {
        Vec::<$t>::new()
    };
}
```

---

## 📚 总结

### 核心要点

1. **宏是元编程工具** - 在编译时生成代码
2. **两大类宏** - 声明宏和过程宏
3. **使用时机** - 减少重复、编译时验证、创建 DSL
4. **优先使用函数** - 除非宏有明显优势

### 选择指南

| 需求 | 推荐方式 |
|------|---------|
| 简单代码复用 | 函数 |
| 可变参数 | 宏 |
| 编译时计算 | 宏 |
| 类型转换 | 函数 |
| 自动实现 trait | 派生宏 |
| 添加元数据 | 属性宏 |
| DSL | 宏 |

### 记忆口诀

- **宏** = **元编程**（生成代码的代码）
- **声明宏** = **模式匹配**（macro_rules!）
- **过程宏** = **操作 AST**（更强大）
- **使用时机** = **无法用函数实现时**

掌握宏是成为 Rust 高手的关键！🦀✨

