# Rust ç”Ÿå‘½å‘¨æœŸå®æˆ˜åœºæ™¯

## ğŸ¯ æ ¸å¿ƒåŸåˆ™ï¼šä»€ä¹ˆæ—¶å€™éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ï¼Ÿ

### ç®€å•åˆ¤æ–­æ³•åˆ™

```rust
// âœ… ä¸éœ€è¦æ ‡æ³¨ - ç¼–è¯‘å™¨èƒ½è‡ªåŠ¨æ¨æ–­
fn simple(s: &str) -> &str {
    s  // åªæœ‰ä¸€ä¸ªè¾“å…¥å¼•ç”¨ï¼Œè¿”å›å®ƒ
}

// âŒ éœ€è¦æ ‡æ³¨ - ç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›å“ªä¸ªå¼•ç”¨
fn complex(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

**æ ¸å¿ƒè§„åˆ™**ï¼š
- âœ… **å•ä¸ªè¾“å…¥å¼•ç”¨** â†’ ä¸éœ€è¦æ ‡æ³¨
- âŒ **å¤šä¸ªè¾“å…¥å¼•ç”¨** â†’ éœ€è¦æ ‡æ³¨
- âŒ **ç»“æ„ä½“æŒæœ‰å¼•ç”¨** â†’ éœ€è¦æ ‡æ³¨
- âŒ **è¿”å›å€¼ä¸å¤šä¸ªå‚æ•°ç›¸å…³** â†’ éœ€è¦æ ‡æ³¨

---

## ğŸ“ åœºæ™¯ 1: é…ç½®æ–‡ä»¶è§£æå™¨

### ä¸šåŠ¡éœ€æ±‚
è§£æé…ç½®æ–‡ä»¶ï¼Œè¿”å›é…ç½®é¡¹çš„å¼•ç”¨ï¼Œé¿å…å¤åˆ¶å¤§é‡å­—ç¬¦ä¸²ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›å“ªä¸ª

```rust
struct Config {
    content: String,
}

impl Config {
    // âŒ ç¼–è¯‘é”™è¯¯ï¼
    fn get_value(&self, key: &str) -> &str {
        // è¿”å›å€¼å¯èƒ½æ¥è‡ª self.contentï¼Œä¹Ÿå¯èƒ½æ¥è‡ª key
        if key == "default" {
            "default_value"  // æ¥è‡ªå­—ç¬¦ä¸²å­—é¢é‡
        } else {
            self.content.as_str()  // æ¥è‡ª self
        }
    }
}
```

**é”™è¯¯ä¿¡æ¯**:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:6:41
  |
6 |     fn get_value(&self, key: &str) -> &str {
  |                  -----       ----     ^ expected named lifetime parameter
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ˜ç¡®æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ

```rust
struct Config {
    content: String,
}

impl Config {
    // âœ… æ˜ç¡®å‘Šè¯‰ç¼–è¯‘å™¨ï¼šè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    fn get_value<'a>(&'a self, key: &str) -> &'a str {
        if key == "default" {
            "default_value"  // 'static å¯ä»¥è½¬æ¢ä¸º 'a
        } else {
            self.content.as_str()  // ç”Ÿå‘½å‘¨æœŸæ˜¯ 'a
        }
    }
}

fn main() {
    let config = Config {
        content: String::from("server_port=8080"),
    };
    
    let value = config.get_value("port");
    println!("Value: {}", value);
    // value çš„ç”Ÿå‘½å‘¨æœŸå—é™äº config
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- æœ‰ä¸¤ä¸ªè¾“å…¥å¼•ç”¨ï¼š`&self` å’Œ `key`
- è¿”å›å€¼å¯èƒ½æ¥è‡ªä»»æ„ä¸€ä¸ª
- å¿…é¡»æ˜ç¡®å‘Šè¯‰ç¼–è¯‘å™¨è¿”å›å€¼ä¸å“ªä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³

---

## ğŸ” åœºæ™¯ 2: æ—¥å¿—è¿‡æ»¤å™¨

### ä¸šåŠ¡éœ€æ±‚
ä»æ—¥å¿—åˆ—è¡¨ä¸­ç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„æ—¥å¿—è¡Œï¼Œè¿”å›å¼•ç”¨è€Œä¸æ˜¯å¤åˆ¶ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šå¤šä¸ªè¾“å…¥ï¼Œä¸çŸ¥é“è¿”å›å“ªä¸ª

```rust
struct LogFilter;

impl LogFilter {
    // âŒ ç¼–è¯‘é”™è¯¯ï¼
    fn filter_by_level(logs: &Vec<String>, level: &str) -> Vec<&str> {
        logs.iter()
            .map(|log| log.as_str())
            .filter(|log| log.contains(level))
            .collect()
    }
}
```

**é”™è¯¯ä¿¡æ¯**:
```
error[E0106]: missing lifetime specifier
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ ‡æ³¨è¿”å›å€¼æ¥è‡ª logs

```rust
struct LogFilter;

impl LogFilter {
    // âœ… æ˜ç¡®ï¼šè¿”å›çš„å¼•ç”¨æ¥è‡ª logsï¼Œä¸ level æ— å…³
    fn filter_by_level<'a>(logs: &'a Vec<String>, level: &str) -> Vec<&'a str> {
        logs.iter()
            .map(|log| log.as_str())
            .filter(|log| log.contains(level))
            .collect()
    }
}

fn main() {
    let logs = vec![
        String::from("[INFO] Server started"),
        String::from("[ERROR] Connection failed"),
        String::from("[INFO] Request processed"),
    ];
    
    let level = String::from("ERROR");
    let errors = LogFilter::filter_by_level(&logs, &level);
    
    // level å¯ä»¥è¢«é”€æ¯ï¼Œå› ä¸ºè¿”å›å€¼ä¸ä¾èµ–å®ƒ
    drop(level);
    
    for error in errors {
        println!("{}", error);
    }
    // errors çš„ç”Ÿå‘½å‘¨æœŸå—é™äº logs
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- æœ‰ä¸¤ä¸ªè¾“å…¥å¼•ç”¨ï¼š`logs` å’Œ `level`
- è¿”å›å€¼åªæ¥è‡ª `logs`
- æ ‡æ³¨ `'a` æ˜ç¡®äº†è¿™ä¸ªå…³ç³»

---

## ğŸ“Š åœºæ™¯ 3: æ•°æ®åº“æŸ¥è¯¢ç»“æœç¼“å­˜

### ä¸šåŠ¡éœ€æ±‚
ç¼“å­˜æ•°æ®åº“æŸ¥è¯¢ç»“æœï¼Œé¿å…é‡å¤æŸ¥è¯¢ã€‚ç»“æ„ä½“æŒæœ‰æŸ¥è¯¢ç»“æœçš„å¼•ç”¨ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šç»“æ„ä½“æŒæœ‰å¼•ç”¨å¿…é¡»æ ‡æ³¨

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼
struct QueryCache {
    query: String,
    result: &Vec<String>,  // å¼•ç”¨å¿…é¡»æœ‰ç”Ÿå‘½å‘¨æœŸ
}
```

**é”™è¯¯ä¿¡æ¯**:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:4:13
  |
4 |     result: &Vec<String>,
  |             ^ expected named lifetime parameter
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šç»“æ„ä½“å£°æ˜ç”Ÿå‘½å‘¨æœŸ

```rust
// âœ… ç»“æ„ä½“æŒæœ‰å¼•ç”¨ï¼Œå¿…é¡»å£°æ˜ç”Ÿå‘½å‘¨æœŸ
struct QueryCache<'a> {
    query: String,
    result: &'a Vec<String>,
}

impl<'a> QueryCache<'a> {
    fn new(query: String, result: &'a Vec<String>) -> Self {
        QueryCache { query, result }
    }
    
    fn get_first(&self) -> Option<&str> {
        self.result.first().map(|s| s.as_str())
    }
}

fn main() {
    let db_result = vec![
        String::from("user1"),
        String::from("user2"),
    ];
    
    let cache = QueryCache::new(
        String::from("SELECT * FROM users"),
        &db_result,
    );
    
    if let Some(first) = cache.get_first() {
        println!("First user: {}", first);
    }
    
    // cache ä¸èƒ½æ¯” db_result æ´»å¾—æ›´ä¹…
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- ç»“æ„ä½“æŒæœ‰å¼•ç”¨å­—æ®µ
- å¿…é¡»æ˜ç¡®å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
- ç¡®ä¿ç»“æ„ä½“ä¸ä¼šæ¯”å¼•ç”¨çš„æ•°æ®æ´»å¾—æ›´ä¹…

---

## ğŸŒ åœºæ™¯ 4: HTTP è¯·æ±‚è§£æå™¨

### ä¸šåŠ¡éœ€æ±‚
è§£æ HTTP è¯·æ±‚ï¼Œæå– header å’Œ body çš„å¼•ç”¨ï¼Œé¿å…å¤åˆ¶å¤§é‡æ•°æ®ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šå¤šä¸ªå­—æ®µå¼•ç”¨åŒä¸€æ•°æ®

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼
struct HttpRequest {
    method: &str,
    path: &str,
    headers: Vec<&str>,
    body: &str,
}
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ‰€æœ‰å¼•ç”¨å…±äº«åŒä¸€ç”Ÿå‘½å‘¨æœŸ

```rust
// âœ… æ‰€æœ‰å¼•ç”¨å­—æ®µéƒ½æ¥è‡ªåŒä¸€ä¸ªåŸå§‹æ•°æ®
struct HttpRequest<'a> {
    method: &'a str,
    path: &'a str,
    headers: Vec<&'a str>,
    body: &'a str,
}

impl<'a> HttpRequest<'a> {
    fn parse(raw: &'a str) -> Self {
        // ç®€åŒ–çš„è§£æé€»è¾‘
        let lines: Vec<&str> = raw.lines().collect();
        
        HttpRequest {
            method: lines.get(0).unwrap_or(&"GET"),
            path: lines.get(1).unwrap_or(&"/"),
            headers: lines.get(2..5).unwrap_or(&[]).to_vec(),
            body: lines.get(5).unwrap_or(&""),
        }
    }
    
    fn get_header(&self, name: &str) -> Option<&'a str> {
        self.headers.iter()
            .find(|h| h.starts_with(name))
            .copied()
    }
}

fn main() {
    let raw_request = "GET\n/api/users\nContent-Type: application/json\nAuthorization: Bearer token\n\n{\"id\": 1}";
    
    let request = HttpRequest::parse(raw_request);
    
    println!("Method: {}", request.method);
    println!("Path: {}", request.path);
    
    if let Some(auth) = request.get_header("Authorization") {
        println!("Auth: {}", auth);
    }
    
    // request çš„æ‰€æœ‰å­—æ®µéƒ½ä¸èƒ½æ¯” raw_request æ´»å¾—æ›´ä¹…
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- ç»“æ„ä½“æœ‰å¤šä¸ªå¼•ç”¨å­—æ®µ
- æ‰€æœ‰å¼•ç”¨éƒ½æ¥è‡ªåŒä¸€ä¸ªåŸå§‹æ•°æ®
- ç”¨ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•° `'a` ç»Ÿä¸€ç®¡ç†

---

## ğŸ”— åœºæ™¯ 5: é“¾è¡¨èŠ‚ç‚¹å¼•ç”¨

### ä¸šåŠ¡éœ€æ±‚
å®ç°ä¸€ä¸ªç®€å•çš„é“¾è¡¨ï¼ŒèŠ‚ç‚¹ä¹‹é—´é€šè¿‡å¼•ç”¨è¿æ¥ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šèŠ‚ç‚¹å¼•ç”¨å…¶ä»–èŠ‚ç‚¹

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼
struct Node {
    value: i32,
    next: Option<&Node>,  // å¼•ç”¨å¿…é¡»æœ‰ç”Ÿå‘½å‘¨æœŸ
}
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
// âœ… èŠ‚ç‚¹å¯ä»¥å¼•ç”¨å…¶ä»–èŠ‚ç‚¹
struct Node<'a> {
    value: i32,
    next: Option<&'a Node<'a>>,
}

impl<'a> Node<'a> {
    fn new(value: i32) -> Self {
        Node { value, next: None }
    }
    
    fn with_next(value: i32, next: &'a Node<'a>) -> Self {
        Node {
            value,
            next: Some(next),
        }
    }
    
    fn iter(&'a self) -> NodeIter<'a> {
        NodeIter { current: Some(self) }
    }
}

struct NodeIter<'a> {
    current: Option<&'a Node<'a>>,
}

impl<'a> Iterator for NodeIter<'a> {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.current.map(|node| {
            self.current = node.next;
            node.value
        })
    }
}

fn main() {
    let node1 = Node::new(1);
    let node2 = Node::with_next(2, &node1);
    let node3 = Node::with_next(3, &node2);
    
    for value in node3.iter() {
        println!("Value: {}", value);
    }
    // è¾“å‡º: 3, 2, 1
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- èŠ‚ç‚¹å¼•ç”¨å…¶ä»–èŠ‚ç‚¹
- å¿…é¡»ç¡®ä¿è¢«å¼•ç”¨çš„èŠ‚ç‚¹æ¯”å¼•ç”¨å®ƒçš„èŠ‚ç‚¹æ´»å¾—æ›´ä¹…
- è¿­ä»£å™¨ä¹Ÿéœ€è¦ç”Ÿå‘½å‘¨æœŸå‚æ•°

---

## ğŸ“¦ åœºæ™¯ 6: å­—ç¬¦ä¸²åˆ†å‰²å™¨ï¼ˆé›¶æ‹·è´ï¼‰

### ä¸šåŠ¡éœ€æ±‚
åˆ†å‰²å­—ç¬¦ä¸²ä½†ä¸å¤åˆ¶æ•°æ®ï¼Œè¿”å›åŸå­—ç¬¦ä¸²çš„åˆ‡ç‰‡ã€‚

### âŒ é”™è¯¯ç¤ºä¾‹ï¼šè¿”å›å¤šä¸ªå¼•ç”¨

```rust
// âŒ ç¼–è¯‘é”™è¯¯ï¼
fn split_once(s: &str, delimiter: &str) -> (&str, &str) {
    match s.find(delimiter) {
        Some(pos) => (&s[..pos], &s[pos + delimiter.len()..]),
        None => (s, ""),
    }
}
```

**é”™è¯¯ä¿¡æ¯**:
```
error[E0106]: missing lifetime specifier
```

### âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ˜ç¡®è¿”å›å€¼æ¥è‡ªç¬¬ä¸€ä¸ªå‚æ•°

```rust
// âœ… è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ s ç›¸åŒï¼Œä¸ delimiter æ— å…³
fn split_once<'a>(s: &'a str, delimiter: &str) -> (&'a str, &'a str) {
    match s.find(delimiter) {
        Some(pos) => (&s[..pos], &s[pos + delimiter.len()..]),
        None => (s, ""),
    }
}

fn main() {
    let text = String::from("key=value");
    let delim = String::from("=");
    
    let (key, value) = split_once(&text, &delim);
    
    // delim å¯ä»¥è¢«é”€æ¯ï¼Œå› ä¸ºè¿”å›å€¼ä¸ä¾èµ–å®ƒ
    drop(delim);
    
    println!("Key: {}, Value: {}", key, value);
    // key å’Œ value çš„ç”Ÿå‘½å‘¨æœŸå—é™äº text
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ**
- è¿”å›å…ƒç»„åŒ…å«ä¸¤ä¸ªå¼•ç”¨
- ä¸¤ä¸ªå¼•ç”¨éƒ½æ¥è‡ªç¬¬ä¸€ä¸ªå‚æ•° `s`
- æ ‡æ³¨ `'a` æ˜ç¡®äº†è¿™ä¸ªå…³ç³»

---

## ğŸ¨ åœºæ™¯ 7: æ¨¡æ¿å¼•æ“

### ä¸šåŠ¡éœ€æ±‚
æ¨¡æ¿å¼•æ“æŒæœ‰æ¨¡æ¿å­—ç¬¦ä¸²å’Œå˜é‡æ˜ å°„ï¼Œæ¸²æŸ“æ—¶è¿”å›å¼•ç”¨ã€‚

### âœ… å®Œæ•´ç¤ºä¾‹ï¼šå¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
use std::collections::HashMap;

// æ¨¡æ¿å¼•æ“æŒæœ‰æ¨¡æ¿å’Œå˜é‡
struct TemplateEngine<'template, 'vars> {
    template: &'template str,
    variables: &'vars HashMap<String, String>,
}

impl<'template, 'vars> TemplateEngine<'template, 'vars> {
    fn new(
        template: &'template str,
        variables: &'vars HashMap<String, String>,
    ) -> Self {
        TemplateEngine { template, variables }
    }
    
    // è¿”å›å€¼å¯èƒ½æ¥è‡ª template æˆ– variables
    fn get_variable(&self, name: &str) -> Option<&'vars str> {
        self.variables.get(name).map(|s| s.as_str())
    }
    
    fn get_template(&self) -> &'template str {
        self.template
    }
}

fn main() {
    let template = String::from("Hello, {{name}}!");
    let mut vars = HashMap::new();
    vars.insert(String::from("name"), String::from("Alice"));
    
    let engine = TemplateEngine::new(&template, &vars);
    
    println!("Template: {}", engine.get_template());
    
    if let Some(name) = engine.get_variable("name") {
        println!("Name: {}", name);
    }
    
    // engine ä¸èƒ½æ¯” template æˆ– vars æ´»å¾—æ›´ä¹…
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸï¼Ÿ**
- `template` å’Œ `variables` å¯èƒ½æœ‰ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
- è¿”å›å€¼å¯èƒ½æ¥è‡ªä»»æ„ä¸€ä¸ª
- ç”¨ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°åˆ†åˆ«ç®¡ç†

---

## ğŸ“‹ æ€»ç»“ï¼šä½•æ—¶éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ï¼Ÿ

### âœ… å¿…é¡»æ ‡æ³¨çš„æƒ…å†µ

| åœºæ™¯ | åŸå›  | ç¤ºä¾‹ |
|------|------|------|
| **å¤šä¸ªè¾“å…¥å¼•ç”¨** | ç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›å“ªä¸ª | `fn foo(x: &str, y: &str) -> &str` |
| **ç»“æ„ä½“æŒæœ‰å¼•ç”¨** | å¿…é¡»æ˜ç¡®å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ | `struct Foo<'a> { field: &'a str }` |
| **è¿”å›å¤šä¸ªå¼•ç”¨** | å¿…é¡»æ˜ç¡®å¼•ç”¨çš„æ¥æº | `fn foo(s: &str) -> (&str, &str)` |
| **impl å—** | ä¸ºå¸¦ç”Ÿå‘½å‘¨æœŸçš„ç»“æ„ä½“å®ç°æ–¹æ³• | `impl<'a> Foo<'a> { ... }` |

### âŒ ä¸éœ€è¦æ ‡æ³¨çš„æƒ…å†µ

| åœºæ™¯ | åŸå›  | ç¤ºä¾‹ |
|------|------|------|
| **å•ä¸ªè¾“å…¥å¼•ç”¨** | çœç•¥è§„åˆ™ 2 è‡ªåŠ¨æ¨æ–­ | `fn foo(s: &str) -> &str` |
| **æ–¹æ³•è¿”å› self** | çœç•¥è§„åˆ™ 3 è‡ªåŠ¨æ¨æ–­ | `fn get(&self) -> &str` |
| **ä¸è¿”å›å¼•ç”¨** | æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸé—®é¢˜ | `fn foo(s: &str) -> String` |

### ğŸ¯ å®ç”¨å»ºè®®

1. **å…ˆä¸æ ‡æ³¨** - è®©ç¼–è¯‘å™¨æŠ¥é”™
2. **çœ‹é”™è¯¯ä¿¡æ¯** - ç†è§£ç¼–è¯‘å™¨çš„å›°æƒ‘
3. **æœ€å°æ ‡æ³¨** - åªæ ‡æ³¨å¿…è¦çš„åœ°æ–¹
4. **æµ‹è¯•è¾¹ç•Œ** - ç¡®ä¿ç”Ÿå‘½å‘¨æœŸæ­£ç¡®

è®°ä½ï¼š**ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸ä¼šæ”¹å˜å®é™…ç”Ÿå‘½å‘¨æœŸï¼Œåªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨å¼•ç”¨ä¹‹é—´çš„å…³ç³»ï¼** ğŸ¦€

