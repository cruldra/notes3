# Rust 生命周期实战场景

## 🎯 核心原则：什么时候需要手动标注？

### 简单判断法则

```rust
// ✅ 不需要标注 - 编译器能自动推断
fn simple(s: &str) -> &str {
    s  // 只有一个输入引用，返回它
}

// ❌ 需要标注 - 编译器不知道返回哪个引用
fn complex(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

**核心规则**：
- ✅ **单个输入引用** → 不需要标注
- ❌ **多个输入引用** → 需要标注
- ❌ **结构体持有引用** → 需要标注
- ❌ **返回值与多个参数相关** → 需要标注

---

## 📝 场景 1: 配置文件解析器

### 业务需求
解析配置文件，返回配置项的引用，避免复制大量字符串。

### ❌ 错误示例：编译器不知道返回哪个

```rust
struct Config {
    content: String,
}

impl Config {
    // ❌ 编译错误！
    fn get_value(&self, key: &str) -> &str {
        // 返回值可能来自 self.content，也可能来自 key
        if key == "default" {
            "default_value"  // 来自字符串字面量
        } else {
            self.content.as_str()  // 来自 self
        }
    }
}
```

**错误信息**:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:6:41
  |
6 |     fn get_value(&self, key: &str) -> &str {
  |                  -----       ----     ^ expected named lifetime parameter
```

### ✅ 正确示例：明确标注生命周期

```rust
struct Config {
    content: String,
}

impl Config {
    // ✅ 明确告诉编译器：返回值的生命周期与 self 相同
    fn get_value<'a>(&'a self, key: &str) -> &'a str {
        if key == "default" {
            "default_value"  // 'static 可以转换为 'a
        } else {
            self.content.as_str()  // 生命周期是 'a
        }
    }
}

fn main() {
    let config = Config {
        content: String::from("server_port=8080"),
    };
    
    let value = config.get_value("port");
    println!("Value: {}", value);
    // value 的生命周期受限于 config
}
```

**为什么需要标注？**
- 有两个输入引用：`&self` 和 `key`
- 返回值可能来自任意一个
- 必须明确告诉编译器返回值与哪个参数的生命周期相关

---

## 🔍 场景 2: 日志过滤器

### 业务需求
从日志列表中筛选出符合条件的日志行，返回引用而不是复制。

### ❌ 错误示例：多个输入，不知道返回哪个

```rust
struct LogFilter;

impl LogFilter {
    // ❌ 编译错误！
    fn filter_by_level(logs: &Vec<String>, level: &str) -> Vec<&str> {
        logs.iter()
            .map(|log| log.as_str())
            .filter(|log| log.contains(level))
            .collect()
    }
}
```

**错误信息**:
```
error[E0106]: missing lifetime specifier
```

### ✅ 正确示例：标注返回值来自 logs

```rust
struct LogFilter;

impl LogFilter {
    // ✅ 明确：返回的引用来自 logs，与 level 无关
    fn filter_by_level<'a>(logs: &'a Vec<String>, level: &str) -> Vec<&'a str> {
        logs.iter()
            .map(|log| log.as_str())
            .filter(|log| log.contains(level))
            .collect()
    }
}

fn main() {
    let logs = vec![
        String::from("[INFO] Server started"),
        String::from("[ERROR] Connection failed"),
        String::from("[INFO] Request processed"),
    ];
    
    let level = String::from("ERROR");
    let errors = LogFilter::filter_by_level(&logs, &level);
    
    // level 可以被销毁，因为返回值不依赖它
    drop(level);
    
    for error in errors {
        println!("{}", error);
    }
    // errors 的生命周期受限于 logs
}
```

**为什么需要标注？**
- 有两个输入引用：`logs` 和 `level`
- 返回值只来自 `logs`
- 标注 `'a` 明确了这个关系

---

## 📊 场景 3: 数据库查询结果缓存

### 业务需求
缓存数据库查询结果，避免重复查询。结构体持有查询结果的引用。

### ❌ 错误示例：结构体持有引用必须标注

```rust
// ❌ 编译错误！
struct QueryCache {
    query: String,
    result: &Vec<String>,  // 引用必须有生命周期
}
```

**错误信息**:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:4:13
  |
4 |     result: &Vec<String>,
  |             ^ expected named lifetime parameter
```

### ✅ 正确示例：结构体声明生命周期

```rust
// ✅ 结构体持有引用，必须声明生命周期
struct QueryCache<'a> {
    query: String,
    result: &'a Vec<String>,
}

impl<'a> QueryCache<'a> {
    fn new(query: String, result: &'a Vec<String>) -> Self {
        QueryCache { query, result }
    }
    
    fn get_first(&self) -> Option<&str> {
        self.result.first().map(|s| s.as_str())
    }
}

fn main() {
    let db_result = vec![
        String::from("user1"),
        String::from("user2"),
    ];
    
    let cache = QueryCache::new(
        String::from("SELECT * FROM users"),
        &db_result,
    );
    
    if let Some(first) = cache.get_first() {
        println!("First user: {}", first);
    }
    
    // cache 不能比 db_result 活得更久
}
```

**为什么需要标注？**
- 结构体持有引用字段
- 必须明确引用的生命周期
- 确保结构体不会比引用的数据活得更久

---

## 🌐 场景 4: HTTP 请求解析器

### 业务需求
解析 HTTP 请求，提取 header 和 body 的引用，避免复制大量数据。

### ❌ 错误示例：多个字段引用同一数据

```rust
// ❌ 编译错误！
struct HttpRequest {
    method: &str,
    path: &str,
    headers: Vec<&str>,
    body: &str,
}
```

### ✅ 正确示例：所有引用共享同一生命周期

```rust
// ✅ 所有引用字段都来自同一个原始数据
struct HttpRequest<'a> {
    method: &'a str,
    path: &'a str,
    headers: Vec<&'a str>,
    body: &'a str,
}

impl<'a> HttpRequest<'a> {
    fn parse(raw: &'a str) -> Self {
        // 简化的解析逻辑
        let lines: Vec<&str> = raw.lines().collect();
        
        HttpRequest {
            method: lines.get(0).unwrap_or(&"GET"),
            path: lines.get(1).unwrap_or(&"/"),
            headers: lines.get(2..5).unwrap_or(&[]).to_vec(),
            body: lines.get(5).unwrap_or(&""),
        }
    }
    
    fn get_header(&self, name: &str) -> Option<&'a str> {
        self.headers.iter()
            .find(|h| h.starts_with(name))
            .copied()
    }
}

fn main() {
    let raw_request = "GET\n/api/users\nContent-Type: application/json\nAuthorization: Bearer token\n\n{\"id\": 1}";
    
    let request = HttpRequest::parse(raw_request);
    
    println!("Method: {}", request.method);
    println!("Path: {}", request.path);
    
    if let Some(auth) = request.get_header("Authorization") {
        println!("Auth: {}", auth);
    }
    
    // request 的所有字段都不能比 raw_request 活得更久
}
```

**为什么需要标注？**
- 结构体有多个引用字段
- 所有引用都来自同一个原始数据
- 用一个生命周期参数 `'a` 统一管理

---

## 🔗 场景 5: 链表节点引用

### 业务需求
实现一个简单的链表，节点之间通过引用连接。

### ❌ 错误示例：节点引用其他节点

```rust
// ❌ 编译错误！
struct Node {
    value: i32,
    next: Option<&Node>,  // 引用必须有生命周期
}
```

### ✅ 正确示例：使用生命周期参数

```rust
// ✅ 节点可以引用其他节点
struct Node<'a> {
    value: i32,
    next: Option<&'a Node<'a>>,
}

impl<'a> Node<'a> {
    fn new(value: i32) -> Self {
        Node { value, next: None }
    }
    
    fn with_next(value: i32, next: &'a Node<'a>) -> Self {
        Node {
            value,
            next: Some(next),
        }
    }
    
    fn iter(&'a self) -> NodeIter<'a> {
        NodeIter { current: Some(self) }
    }
}

struct NodeIter<'a> {
    current: Option<&'a Node<'a>>,
}

impl<'a> Iterator for NodeIter<'a> {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.current.map(|node| {
            self.current = node.next;
            node.value
        })
    }
}

fn main() {
    let node1 = Node::new(1);
    let node2 = Node::with_next(2, &node1);
    let node3 = Node::with_next(3, &node2);
    
    for value in node3.iter() {
        println!("Value: {}", value);
    }
    // 输出: 3, 2, 1
}
```

**为什么需要标注？**
- 节点引用其他节点
- 必须确保被引用的节点比引用它的节点活得更久
- 迭代器也需要生命周期参数

---

## 📦 场景 6: 字符串分割器（零拷贝）

### 业务需求
分割字符串但不复制数据，返回原字符串的切片。

### ❌ 错误示例：返回多个引用

```rust
// ❌ 编译错误！
fn split_once(s: &str, delimiter: &str) -> (&str, &str) {
    match s.find(delimiter) {
        Some(pos) => (&s[..pos], &s[pos + delimiter.len()..]),
        None => (s, ""),
    }
}
```

**错误信息**:
```
error[E0106]: missing lifetime specifier
```

### ✅ 正确示例：明确返回值来自第一个参数

```rust
// ✅ 返回值的生命周期与 s 相同，与 delimiter 无关
fn split_once<'a>(s: &'a str, delimiter: &str) -> (&'a str, &'a str) {
    match s.find(delimiter) {
        Some(pos) => (&s[..pos], &s[pos + delimiter.len()..]),
        None => (s, ""),
    }
}

fn main() {
    let text = String::from("key=value");
    let delim = String::from("=");
    
    let (key, value) = split_once(&text, &delim);
    
    // delim 可以被销毁，因为返回值不依赖它
    drop(delim);
    
    println!("Key: {}, Value: {}", key, value);
    // key 和 value 的生命周期受限于 text
}
```

**为什么需要标注？**
- 返回元组包含两个引用
- 两个引用都来自第一个参数 `s`
- 标注 `'a` 明确了这个关系

---

## 🎨 场景 7: 模板引擎

### 业务需求
模板引擎持有模板字符串和变量映射，渲染时返回引用。

### ✅ 完整示例：多个生命周期参数

```rust
use std::collections::HashMap;

// 模板引擎持有模板和变量
struct TemplateEngine<'template, 'vars> {
    template: &'template str,
    variables: &'vars HashMap<String, String>,
}

impl<'template, 'vars> TemplateEngine<'template, 'vars> {
    fn new(
        template: &'template str,
        variables: &'vars HashMap<String, String>,
    ) -> Self {
        TemplateEngine { template, variables }
    }
    
    // 返回值可能来自 template 或 variables
    fn get_variable(&self, name: &str) -> Option<&'vars str> {
        self.variables.get(name).map(|s| s.as_str())
    }
    
    fn get_template(&self) -> &'template str {
        self.template
    }
}

fn main() {
    let template = String::from("Hello, {{name}}!");
    let mut vars = HashMap::new();
    vars.insert(String::from("name"), String::from("Alice"));
    
    let engine = TemplateEngine::new(&template, &vars);
    
    println!("Template: {}", engine.get_template());
    
    if let Some(name) = engine.get_variable("name") {
        println!("Name: {}", name);
    }
    
    // engine 不能比 template 或 vars 活得更久
}
```

**为什么需要两个生命周期？**
- `template` 和 `variables` 可能有不同的生命周期
- 返回值可能来自任意一个
- 用两个生命周期参数分别管理

---

## 📋 总结：何时需要手动标注？

### ✅ 必须标注的情况

| 场景 | 原因 | 示例 |
|------|------|------|
| **多个输入引用** | 编译器不知道返回哪个 | `fn foo(x: &str, y: &str) -> &str` |
| **结构体持有引用** | 必须明确引用的生命周期 | `struct Foo<'a> { field: &'a str }` |
| **返回多个引用** | 必须明确引用的来源 | `fn foo(s: &str) -> (&str, &str)` |
| **impl 块** | 为带生命周期的结构体实现方法 | `impl<'a> Foo<'a> { ... }` |

### ❌ 不需要标注的情况

| 场景 | 原因 | 示例 |
|------|------|------|
| **单个输入引用** | 省略规则 2 自动推断 | `fn foo(s: &str) -> &str` |
| **方法返回 self** | 省略规则 3 自动推断 | `fn get(&self) -> &str` |
| **不返回引用** | 没有生命周期问题 | `fn foo(s: &str) -> String` |

### 🎯 实用建议

1. **先不标注** - 让编译器报错
2. **看错误信息** - 理解编译器的困惑
3. **最小标注** - 只标注必要的地方
4. **测试边界** - 确保生命周期正确

记住：**生命周期标注不会改变实际生命周期，只是告诉编译器引用之间的关系！** 🦀

