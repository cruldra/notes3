# Rust 值与引用详解

## 📚 核心概念

在 Rust 中，**值（Value）** 和 **引用（Reference）** 是两个最基础也最重要的概念，它们与所有权系统紧密相关。

### 什么是值？

**值** 是实际存储在内存中的数据。在 Rust 中：
- ✅ 每个值都有一个**所有者**（变量）
- ✅ 一个值在同一时刻只能有**一个所有者**
- ✅ 当所有者离开作用域时，值会被**销毁**

### 什么是引用？

**引用** 是指向值的指针，允许你使用值但**不获取所有权**。
- ✅ 引用用 `&` 符号表示
- ✅ 引用不拥有数据，只是"借用"数据
- ✅ 引用离开作用域时，数据不会被销毁

---

## 🎯 值的所有权

### 1. 所有权三原则

```rust
fn main() {
    let s = String::from("hello");  // s 拥有字符串的所有权
    
    // 原则 1: 每个值都有一个所有者（这里是 s）
    // 原则 2: 同一时刻只能有一个所有者
    // 原则 3: 所有者离开作用域时，值被销毁
}  // s 离开作用域，String 被销毁
```

### 2. 值的存储位置

#### 栈（Stack）
- **特点**: 后进先出（LIFO）
- **存储**: 已知固定大小的数据
- **速度**: 非常快
- **示例**: 整数、浮点数、布尔值、字符

```rust
fn main() {
    let x = 5;        // 存储在栈上
    let y = true;     // 存储在栈上
    let z = 3.14;     // 存储在栈上
}
```

#### 堆（Heap）
- **特点**: 无组织结构
- **存储**: 大小未知或可变的数据
- **速度**: 相对较慢（需要分配和查找）
- **示例**: String、Vec、Box

```rust
fn main() {
    let s = String::from("hello");  // 数据存储在堆上
    let v = vec![1, 2, 3];          // 数据存储在堆上
}
```

### 3. 值的移动（Move）

**默认行为**: 赋值时，值的所有权会**转移**。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 的所有权转移给 s2
    
    // println!("{}", s1);  // ❌ 错误！s1 已失效
    println!("{}", s2);     // ✅ 正确
}
```

**为什么要移动？**
- 防止**二次释放**（double free）
- 确保内存安全
- 避免数据竞争

#### 移动的内存模型

```rust
// 移动前
let s1 = String::from("hello");
// 栈: s1 -> [ptr, len, cap]
// 堆: "hello"

// 移动后
let s2 = s1;
// 栈: s1 (无效), s2 -> [ptr, len, cap]
// 堆: "hello"
```

---

## 📋 值的拷贝（Copy）

### 1. Copy Trait

某些类型实现了 `Copy` trait，赋值时会**自动拷贝**而不是移动。

```rust
fn main() {
    let x = 5;
    let y = x;  // 拷贝 x 的值给 y
    
    println!("x = {}, y = {}", x, y);  // ✅ x 和 y 都可用
}
```

### 2. 实现了 Copy 的类型

| 类型 | 示例 |
|------|------|
| **整数** | `i32`, `u64`, `isize` |
| **浮点数** | `f32`, `f64` |
| **布尔** | `bool` |
| **字符** | `char` |
| **元组** | `(i32, i32)` (所有元素都是 Copy) |
| **不可变引用** | `&T` |

### 3. 不能 Copy 的类型

- ❌ `String` - 堆分配
- ❌ `Vec<T>` - 堆分配
- ❌ `Box<T>` - 堆分配
- ❌ `&mut T` - 可变引用

### 4. 自定义类型实现 Copy

```rust
// ✅ 可以实现 Copy（所有字段都是 Copy）
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

// ❌ 不能实现 Copy（包含 String）
struct Person {
    name: String,  // String 不是 Copy
    age: i32,
}
```

---

## 🔄 值的克隆（Clone）

### 1. 深拷贝

`clone()` 方法创建值的**深拷贝**，包括堆上的数据。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深拷贝
    
    println!("s1 = {}, s2 = {}", s1, s2);  // ✅ 都可用
}
```

### 2. Copy vs Clone

| 特性 | Copy | Clone |
|------|------|-------|
| **触发方式** | 自动 | 手动调用 `.clone()` |
| **拷贝深度** | 浅拷贝（栈） | 深拷贝（栈+堆） |
| **性能** | 快 | 可能慢 |
| **适用场景** | 简单类型 | 复杂类型 |

```rust
fn main() {
    // Copy: 自动、快速
    let x = 5;
    let y = x;  // 自动拷贝
    
    // Clone: 手动、可能慢
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 手动克隆
}
```

---

## 🔗 引用（Reference）

### 1. 不可变引用

用 `&` 创建不可变引用，允许读取但不能修改。

```rust
fn main() {
    let s = String::from("hello");
    let r = &s;  // 创建不可变引用
    
    println!("s = {}, r = {}", s, r);  // ✅ 都可用
}  // r 先离开作用域，然后 s 离开作用域并释放内存
```

**特点**:
- ✅ 可以有**多个**不可变引用
- ✅ 不获取所有权
- ✅ 数据不会被修改

```rust
fn main() {
    let s = String::from("hello");
    
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    
    println!("{}, {}, {}", r1, r2, r3);  // ✅ 正确
}
```

### 2. 可变引用

用 `&mut` 创建可变引用，允许修改数据。

```rust
fn main() {
    let mut s = String::from("hello");
    let r = &mut s;  // 创建可变引用
    
    r.push_str(", world");
    println!("{}", r);  // "hello, world"
}
```

**特点**:
- ⚠️ 同一时刻只能有**一个**可变引用
- ⚠️ 可变引用存在时，不能有不可变引用
- ✅ 可以修改数据

### 3. 借用规则

**核心规则**:
1. **要么** 一个可变引用
2. **要么** 任意多个不可变引用
3. 引用必须总是有效的

```rust
fn main() {
    let mut s = String::from("hello");
    
    // ❌ 错误：同时存在可变和不可变引用
    let r1 = &s;
    let r2 = &s;
    let r3 = &mut s;  // 错误！
    
    println!("{}, {}, {}", r1, r2, r3);
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    
    // ✅ 正确：不可变引用的作用域结束后，可以创建可变引用
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);  // r1 和 r2 的作用域在这里结束
    
    let r3 = &mut s;  // ✅ 正确
    println!("{}", r3);
}
```

### 4. 引用的作用域（NLL）

**Non-Lexical Lifetimes (NLL)**: 引用的作用域从创建开始，到**最后一次使用**结束。

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // r1 和 r2 的作用域在这里结束
    
    let r3 = &mut s;  // ✅ 正确
    println!("{}", r3);
}
```

---

## 🎨 解引用（Dereference）

### 1. 基本解引用

用 `*` 操作符解引用，获取引用指向的值。

```rust
fn main() {
    let x = 5;
    let y = &x;  // y 是 x 的引用
    
    assert_eq!(5, x);
    assert_eq!(5, *y);  // 解引用 y
}
```

### 2. 自动解引用

Rust 在某些情况下会自动解引用：

```rust
fn main() {
    let s = String::from("hello");
    let r = &s;
    
    // 自动解引用
    println!("长度: {}", r.len());  // 等价于 (*r).len()
}
```

---

## 📊 函数参数中的值与引用

### 1. 传值（转移所有权）

```rust
fn take_ownership(s: String) {
    println!("{}", s);
}  // s 离开作用域，String 被销毁

fn main() {
    let s = String::from("hello");
    take_ownership(s);
    // println!("{}", s);  // ❌ 错误！s 已失效
}
```

### 2. 传引用（借用）

```rust
fn borrow(s: &String) {
    println!("{}", s);
}  // s 离开作用域，但不销毁 String

fn main() {
    let s = String::from("hello");
    borrow(&s);
    println!("{}", s);  // ✅ 正确！s 仍然有效
}
```

### 3. 传可变引用

```rust
fn modify(s: &mut String) {
    s.push_str(", world");
}

fn main() {
    let mut s = String::from("hello");
    modify(&mut s);
    println!("{}", s);  // "hello, world"
}
```

---

## 💡 实战示例

### 示例 1: 字符串处理

```rust
fn main() {
    let mut text = String::from("Hello");
    
    // 不可变引用：读取
    let len = calculate_length(&text);
    println!("长度: {}", len);
    
    // 可变引用：修改
    append_world(&mut text);
    println!("{}", text);  // "Hello, world!"
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn append_world(s: &mut String) {
    s.push_str(", world!");
}
```

### 示例 2: 数据交换

```rust
fn main() {
    let mut x = 5;
    let mut y = 10;
    
    swap(&mut x, &mut y);
    
    println!("x = {}, y = {}", x, y);  // x = 10, y = 5
}

fn swap(a: &mut i32, b: &mut i32) {
    let temp = *a;
    *a = *b;
    *b = temp;
}
```

### 示例 3: 避免不必要的克隆

```rust
// ❌ 低效：克隆整个 Vec
fn process_bad(v: Vec<i32>) -> i32 {
    v.iter().sum()
}

// ✅ 高效：使用引用
fn process_good(v: &Vec<i32>) -> i32 {
    v.iter().sum()
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // 使用引用，避免克隆
    let sum = process_good(&numbers);
    println!("总和: {}", sum);
    
    // numbers 仍然可用
    println!("数组: {:?}", numbers);
}
```

---

## 🐛 常见错误

### 错误 1: 使用已移动的值

```rust
fn main() {
    let s = String::from("hello");
    let t = s;  // s 的所有权转移给 t
    
    println!("{}", s);  // ❌ 错误！s 已失效
}
```

**解决方案**: 使用引用或克隆

```rust
fn main() {
    let s = String::from("hello");
    let t = &s;  // ✅ 借用
    
    println!("{}", s);
    println!("{}", t);
}
```

### 错误 2: 可变引用冲突

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &mut s;
    let r2 = &mut s;  // ❌ 错误！
    
    println!("{}, {}", r1, r2);
}
```

**解决方案**: 限制作用域

```rust
fn main() {
    let mut s = String::from("hello");
    
    {
        let r1 = &mut s;
        println!("{}", r1);
    }  // r1 离开作用域
    
    let r2 = &mut s;  // ✅ 正确
    println!("{}", r2);
}
```

### 错误 3: 悬垂引用

```rust
fn dangle() -> &String {
    let s = String::from("hello");
    &s  // ❌ 错误！返回局部变量的引用
}  // s 被销毁，引用无效
```

**解决方案**: 返回所有权

```rust
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // ✅ 正确：转移所有权
}
```

---

## 📚 总结

### 值 vs 引用

| 特性 | 值 | 引用 |
|------|-----|------|
| **所有权** | 拥有 | 借用 |
| **离开作用域** | 销毁数据 | 不销毁数据 |
| **修改** | 可以（如果是 `mut`） | 不可变引用不能，可变引用可以 |
| **数量限制** | 一个所有者 | 多个不可变引用或一个可变引用 |

### 最佳实践

1. ✅ **优先使用引用** - 避免不必要的所有权转移
2. ✅ **尽量使用不可变引用** - 更安全
3. ✅ **避免过度克隆** - 影响性能
4. ✅ **理解借用规则** - 编译器是你的朋友
5. ✅ **使用 NLL** - 让引用作用域更灵活

### 记忆口诀

- **值**: 拥有数据，离开销毁
- **引用**: 借用数据，不会销毁
- **Move**: 转移所有权，原变量失效
- **Copy**: 自动拷贝，都可使用
- **Clone**: 手动克隆，深度复制

掌握值与引用是学好 Rust 的关键！🦀✨

