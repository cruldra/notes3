# Rust æ™ºèƒ½æŒ‡é’ˆè¯¦è§£

## ğŸ  ç”¨ç”Ÿæ´»ä¾‹å­ç†è§£æ™ºèƒ½æŒ‡é’ˆï¼ˆæœ€é€šä¿—ç‰ˆæœ¬ï¼‰

### ç”¨ç§Ÿæˆ¿çš„ä¾‹å­ç†è§£

#### æ™®é€šå˜é‡ = ä¹°æˆ¿è‡ªä½

```rust
let house = String::from("æˆ‘çš„æˆ¿å­");
```

- âœ… ä½ **æ‹¥æœ‰**è¿™ä¸ªæˆ¿å­
- âœ… åªæœ‰ä½ ä¸€ä¸ªäººä½
- âœ… ä½ æ¬èµ°ï¼ˆç¦»å¼€ä½œç”¨åŸŸï¼‰æ—¶ï¼Œæˆ¿å­è¢«æ‹†æ‰ï¼ˆå†…å­˜é‡Šæ”¾ï¼‰

#### Box = åœ¨å¦ä¸€ä¸ªåœ°æ–¹ä¹°æˆ¿

```rust
let house = Box::new(String::from("è¿œæ–¹çš„æˆ¿å­"));
```

- âœ… ä½ ä»ç„¶**æ‹¥æœ‰**è¿™ä¸ªæˆ¿å­
- âœ… ä½†æˆ¿å­å»ºåœ¨**å †**ä¸Šï¼ˆè¿œæ–¹ï¼‰ï¼Œä¸æ˜¯**æ ˆ**ä¸Šï¼ˆèº«è¾¹ï¼‰
- âœ… ä½ æ‰‹é‡Œæ‹¿ç€**é’¥åŒ™**ï¼ˆæŒ‡é’ˆï¼‰
- âœ… ä½ ä¸è¦è¿™ä¸ªæˆ¿å­æ—¶ï¼Œå®ƒä¼šè¢«è‡ªåŠ¨æ‹†æ‰

**ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ**
- æˆ¿å­å¤ªå¤§ï¼Œèº«è¾¹æ”¾ä¸ä¸‹ï¼ˆæ ˆç©ºé—´æœ‰é™ï¼‰
- éœ€è¦æŠŠæˆ¿å­ä¼ ç»™åˆ«äººï¼Œåªä¼ é’¥åŒ™å¾ˆå¿«ï¼ˆä¸ç”¨æ¬æ•´ä¸ªæˆ¿å­ï¼‰

#### Rc = åˆç§Ÿæˆ¿ï¼ˆå•çº¿ç¨‹ï¼‰

```rust
use std::rc::Rc;

let house = Rc::new(String::from("åˆç§Ÿæˆ¿"));
let roommate1 = Rc::clone(&house);  // å®¤å‹1
let roommate2 = Rc::clone(&house);  // å®¤å‹2
```

- âœ… **å¤šä¸ªäºº**å…±äº«ä¸€ä¸ªæˆ¿å­
- âœ… æ¯ä¸ªäººéƒ½æœ‰é’¥åŒ™
- âœ… è®°å½•æœ‰å¤šå°‘äººä½ï¼ˆå¼•ç”¨è®¡æ•°ï¼‰
- âœ… æœ€åä¸€ä¸ªäººæ¬èµ°æ—¶ï¼Œæˆ¿å­æ‰è¢«æ‹†æ‰
- âš ï¸ ä½†æ˜¯**ä¸èƒ½æ”¹è£…æˆ¿å­**ï¼ˆåªè¯»ï¼‰

**ç”Ÿæ´»åœºæ™¯**ï¼š
```rust
// å°±åƒå‡ ä¸ªå®¤å‹å…±äº«ä¸€ä¸ª WiFi å¯†ç 
let wifi_password = Rc::new(String::from("12345678"));
let roommate1_knows = Rc::clone(&wifi_password);
let roommate2_knows = Rc::clone(&wifi_password);

// å¤§å®¶éƒ½èƒ½çœ‹å¯†ç ï¼Œä½†ä¸èƒ½æ”¹å¯†ç 
```

#### Arc = åˆç§Ÿæˆ¿ï¼ˆå¤šçº¿ç¨‹ï¼Œæœ‰ä¿å®‰ï¼‰

```rust
use std::sync::Arc;

let house = Arc::new(String::from("é«˜çº§åˆç§Ÿæˆ¿"));
```

- âœ… å’Œ Rc ä¸€æ ·ï¼Œå¤šä¸ªäººå…±äº«
- âœ… ä½†æ˜¯æœ‰**ä¿å®‰**ï¼ˆåŸå­æ“ä½œï¼‰ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
- âœ… å¯ä»¥åœ¨**ä¸åŒçš„çº¿ç¨‹**ä¸­ä½¿ç”¨
- âš ï¸ ä»ç„¶**ä¸èƒ½æ”¹è£…æˆ¿å­**ï¼ˆåªè¯»ï¼‰

**ç”Ÿæ´»åœºæ™¯**ï¼š
```rust
// å°±åƒå…¬å¸å¤šä¸ªéƒ¨é—¨å…±äº«ä¸€ä»½é…ç½®æ–‡ä»¶
let config = Arc::new(String::from("å…¬å¸é…ç½®"));

// ä¸åŒéƒ¨é—¨ï¼ˆçº¿ç¨‹ï¼‰éƒ½èƒ½è¯»å–
```

#### RefCell = å¯ä»¥æ”¹è£…çš„æˆ¿å­ï¼ˆä½†è¦ç™»è®°ï¼‰

```rust
use std::cell::RefCell;

let house = RefCell::new(String::from("æˆ‘çš„æˆ¿å­"));
house.borrow_mut().push_str(" + æ–°è£…ä¿®");  // æ”¹è£…
```

- âœ… å¯ä»¥**ä¿®æ”¹**å†…å®¹
- âš ï¸ ä½†æ˜¯è¦**è¿è¡Œæ—¶æ£€æŸ¥**ï¼ˆåƒç‰©ä¸šç™»è®°ï¼‰
- âš ï¸ å¦‚æœè¿åè§„åˆ™ä¼š**å´©æºƒ**ï¼ˆpanicï¼‰

**ç”Ÿæ´»åœºæ™¯**ï¼š
```rust
// å°±åƒä¸€ä¸ªå¯ä»¥ä¿®æ”¹çš„è´­ç‰©æ¸…å•
let shopping_list = RefCell::new(vec!["è‹¹æœ", "é¦™è•‰"]);
shopping_list.borrow_mut().push("æ©™å­");  // æ·»åŠ æ–°é¡¹ç›®
```

#### Mutex = å¸¦é”çš„æˆ¿é—´

```rust
use std::sync::Mutex;

let room = Mutex::new(String::from("é‡è¦æ–‡ä»¶"));
let mut file = room.lock().unwrap();  // ä¸Šé”ï¼Œåªæœ‰æˆ‘èƒ½è¿›
*file = String::from("ä¿®æ”¹åçš„æ–‡ä»¶");
// ç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨è§£é”
```

- âœ… åŒä¸€æ—¶é—´åªæœ‰**ä¸€ä¸ªäºº**èƒ½è¿›å»
- âœ… è¿›å»çš„äººå¯ä»¥**ä¿®æ”¹**ä¸œè¥¿
- âœ… å‡ºæ¥åè‡ªåŠ¨**è§£é”**ï¼Œä¸‹ä¸€ä¸ªäººæ‰èƒ½è¿›
- âš ï¸ å¦‚æœå¿˜è®°å‡ºæ¥ï¼Œä¼š**æ­»é”**

**ç”Ÿæ´»åœºæ™¯**ï¼š
```rust
// å°±åƒé“¶è¡Œçš„ä¿é™©ç®±
let safe = Mutex::new(1000);  // 1000 å…ƒ

// åªæœ‰æ‹¿åˆ°é’¥åŒ™çš„äººæ‰èƒ½å­˜å–é’±
let mut money = safe.lock().unwrap();
*money += 500;  // å­˜ 500 å…ƒ
```

---

## ğŸ• ç”¨æŠ«è¨çš„ä¾‹å­ç†è§£

### æ™®é€šå˜é‡ = ä½ è‡ªå·±çš„æŠ«è¨

```rust
let my_pizza = String::from("ğŸ•");
```

- ä½ ä¸€ä¸ªäººåƒ
- åƒå®Œå°±æ²¡äº†

### Box = å¤–å–æŠ«è¨

```rust
let pizza = Box::new(String::from("ğŸ•"));
```

- æŠ«è¨åœ¨å¤–å–ç®±é‡Œï¼ˆå †ï¼‰
- ä½ æ‹¿ç€å¤–å–å•ï¼ˆæŒ‡é’ˆï¼‰
- åƒå®Œåï¼Œå¤–å–ç®±è‡ªåŠ¨å›æ”¶

### Rc = å’Œæœ‹å‹åˆ†äº«æŠ«è¨ï¼ˆåœ¨å®¶é‡Œï¼‰

```rust
use std::rc::Rc;

let pizza = Rc::new(String::from("ğŸ•"));
let friend1 = Rc::clone(&pizza);  // æœ‹å‹1ä¹Ÿèƒ½åƒ
let friend2 = Rc::clone(&pizza);  // æœ‹å‹2ä¹Ÿèƒ½åƒ
```

- å¤§å®¶éƒ½èƒ½çœ‹åˆ°æŠ«è¨
- ä½†**ä¸èƒ½æ”¹å˜**æŠ«è¨ï¼ˆåªèƒ½çœ‹ï¼Œä¸èƒ½åŠ æ–™ï¼‰
- æœ€åä¸€ä¸ªäººç¦»å¼€ï¼ŒæŠ«è¨æ‰è¢«æ”¶èµ°

### Rc + RefCell = å¯ä»¥åŠ æ–™çš„å…±äº«æŠ«è¨

```rust
use std::rc::Rc;
use std::cell::RefCell;

let pizza = Rc::new(RefCell::new(vec!["èŠå£«", "ç•ªèŒ„"]));

let friend1 = Rc::clone(&pizza);
friend1.borrow_mut().push("åŸ¹æ ¹");  // æœ‹å‹1åŠ åŸ¹æ ¹

let friend2 = Rc::clone(&pizza);
println!("{:?}", friend2.borrow());  // æœ‹å‹2çœ‹åˆ°ï¼š["èŠå£«", "ç•ªèŒ„", "åŸ¹æ ¹"]
```

- å¤§å®¶éƒ½èƒ½çœ‹åˆ°æŠ«è¨
- è€Œä¸”å¯ä»¥**åŠ æ–™**ï¼ˆä¿®æ”¹ï¼‰
- æ‰€æœ‰äººçœ‹åˆ°çš„éƒ½æ˜¯åŒä¸€ä¸ªæŠ«è¨

### Arc + Mutex = å¤šä¸ªå¨æˆ¿å…±äº«çš„æŠ«è¨ï¼ˆè¦æ’é˜Ÿï¼‰

```rust
use std::sync::{Arc, Mutex};

let pizza = Arc::new(Mutex::new(vec!["èŠå£«"]));

// å¨å¸ˆ1
let pizza1 = Arc::clone(&pizza);
pizza1.lock().unwrap().push("åŸ¹æ ¹");  // åŠ åŸ¹æ ¹ï¼ˆæ’é˜Ÿç­‰å¾…ï¼‰

// å¨å¸ˆ2
let pizza2 = Arc::clone(&pizza);
pizza2.lock().unwrap().push("è˜‘è‡");  // åŠ è˜‘è‡ï¼ˆæ’é˜Ÿç­‰å¾…ï¼‰
```

- å¤šä¸ªå¨å¸ˆï¼ˆçº¿ç¨‹ï¼‰å…±äº«
- åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªäººèƒ½åŠ æ–™
- è¦æ’é˜Ÿï¼ˆåŠ é”ï¼‰

---

## ğŸ® ç”¨æ¸¸æˆçš„ä¾‹å­ç†è§£

### Box = èƒŒåŒ…é‡Œçš„ç‰©å“

```rust
struct Sword {
    damage: i32,
}

let my_sword = Box::new(Sword { damage: 100 });
```

- å‰‘å¤ªå¤§ï¼Œä¸èƒ½ç›´æ¥æ‹¿åœ¨æ‰‹ä¸Šï¼ˆæ ˆï¼‰
- æ”¾åœ¨èƒŒåŒ…é‡Œï¼ˆå †ï¼‰
- ä½ æ‹¿ç€èƒŒåŒ…çš„é’¥åŒ™ï¼ˆæŒ‡é’ˆï¼‰

### Rc = å…±äº«çš„ä»»åŠ¡

```rust
use std::rc::Rc;

let quest = Rc::new(String::from("å‡»è´¥æ¶é¾™"));
let player1 = Rc::clone(&quest);  // ç©å®¶1æ¥ä»»åŠ¡
let player2 = Rc::clone(&quest);  // ç©å®¶2æ¥ä»»åŠ¡
```

- å¤šä¸ªç©å®¶å¯ä»¥æ¥åŒä¸€ä¸ªä»»åŠ¡
- ä»»åŠ¡å†…å®¹ä¸èƒ½æ”¹
- æ‰€æœ‰ç©å®¶éƒ½æ”¾å¼ƒæ—¶ï¼Œä»»åŠ¡æ¶ˆå¤±

### Arc = å¤šäººåœ¨çº¿æ¸¸æˆçš„å…±äº«æ•°æ®

```rust
use std::sync::Arc;

let game_map = Arc::new(String::from("ä¸–ç•Œåœ°å›¾"));
// å¤šä¸ªç©å®¶ï¼ˆçº¿ç¨‹ï¼‰åŒæ—¶çœ‹åœ°å›¾
```

### Mutex = åªèƒ½ä¸€ä¸ªäººç”¨çš„å®ç®±

```rust
use std::sync::Mutex;

let treasure = Mutex::new(1000);  // 1000 é‡‘å¸

// ç©å®¶1æ‰“å¼€å®ç®±
let mut gold = treasure.lock().unwrap();
*gold -= 100;  // æ‹¿èµ°100é‡‘å¸
// è‡ªåŠ¨å…³é—­å®ç®±
```

---

## ğŸ¯ æœ€ç®€å•çš„æ€»ç»“

### ä»€ä¹ˆæ—¶å€™ç”¨ä»€ä¹ˆï¼Ÿ

| åœºæ™¯ | ç”¨ä»€ä¹ˆ | ç”Ÿæ´»ä¾‹å­ |
|------|--------|---------|
| æ•°æ®å¤ªå¤§ | `Box` | å¤§ä»¶ç‰©å“æ”¾ä»“åº“ |
| å¤šäººå…±äº«ï¼ˆåªçœ‹ï¼‰ | `Rc` | å…±äº« WiFi å¯†ç  |
| å¤šçº¿ç¨‹å…±äº«ï¼ˆåªçœ‹ï¼‰ | `Arc` | å…¬å¸å…±äº«é…ç½® |
| éœ€è¦ä¿®æ”¹ | `RefCell` | å¯ä¿®æ”¹çš„è´­ç‰©æ¸…å• |
| å¤šçº¿ç¨‹ä¿®æ”¹ | `Mutex` | é“¶è¡Œä¿é™©ç®± |

### è®°å¿†å£è¯€

- **Box** = **ç›’å­**ï¼Œè£…å¤§ä¸œè¥¿
- **Rc** = **R**oom**c**matesï¼ˆå®¤å‹ï¼‰ï¼Œå•çº¿ç¨‹åˆç§Ÿ
- **Arc** = **A**tomic **Rc**ï¼ˆåŸå­Rcï¼‰ï¼Œå¤šçº¿ç¨‹åˆç§Ÿ
- **RefCell** = **Ref**erence **Cell**ï¼ˆå¼•ç”¨å•å…ƒï¼‰ï¼Œå¯ä»¥æ”¹
- **Mutex** = **Mut**ual **Ex**clusionï¼ˆäº’æ–¥ï¼‰ï¼Œè¦æ’é˜Ÿ

---

## ğŸ¤” æœ€ç®€å•çš„ç©å…·ä¾‹å­

```rust
// 1. æ™®é€šå˜é‡ - æˆ‘çš„ç©å…·
let toy = String::from("ğŸš—");
// åªæœ‰æˆ‘èƒ½ç©ï¼Œæˆ‘ä¸ç©äº†å°±æ‰”æ‰

// 2. Box - å¤§ç©å…·æ”¾ä»“åº“
let big_toy = Box::new(String::from("ğŸš‚"));
// ç©å…·å¤ªå¤§ï¼Œæ”¾ä»“åº“ï¼Œæˆ‘æ‹¿ç€é’¥åŒ™

// 3. Rc - å’Œå¼Ÿå¼Ÿå…±äº«ç©å…·
use std::rc::Rc;
let shared_toy = Rc::new(String::from("ğŸ®"));
let brother = Rc::clone(&shared_toy);
// æˆ‘å’Œå¼Ÿå¼Ÿéƒ½èƒ½ç©ï¼Œä½†ä¸èƒ½æ‹†ï¼ˆåªè¯»ï¼‰

// 4. RefCell - å¯ä»¥æ”¹è£…çš„ç©å…·
use std::cell::RefCell;
let modifiable_toy = RefCell::new(String::from("ğŸ¤–"));
modifiable_toy.borrow_mut().push_str(" + æ–°æ­¦å™¨");
// å¯ä»¥ç»™ç©å…·åŠ è£…å¤‡

// 5. Rc + RefCell - å…±äº«çš„å¯æ”¹è£…ç©å…·
let shared_modifiable = Rc::new(RefCell::new(String::from("ğŸ°")));
let brother2 = Rc::clone(&shared_modifiable);
brother2.borrow_mut().push_str(" + åŸå¢™");
// æˆ‘å’Œå¼Ÿå¼Ÿéƒ½èƒ½ç©ï¼Œéƒ½èƒ½æ”¹è£…

// 6. Mutex - è¦æ’é˜Ÿç©çš„ç©å…·
use std::sync::Mutex;
let exclusive_toy = Mutex::new(String::from("ğŸ¯"));
let mut my_turn = exclusive_toy.lock().unwrap();
*my_turn = String::from("ğŸ¯ æˆ‘ç©è¿‡äº†");
// åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªäººèƒ½ç©
```

---

## ğŸ“š æŠ€æœ¯å®šä¹‰ï¼ˆçœ‹å®Œä¸Šé¢å†çœ‹è¿™ä¸ªï¼‰

### ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Ÿ

**æ™ºèƒ½æŒ‡é’ˆ**ï¼ˆSmart Pointerï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ•°æ®ç»“æ„ï¼Œå®ƒä¸ä»…åƒæŒ‡é’ˆä¸€æ ·å­˜å‚¨å†…å­˜åœ°å€ï¼Œè¿˜åŒ…å«é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½ã€‚

### ä¸æ™®é€šå¼•ç”¨çš„åŒºåˆ«

| ç‰¹æ€§ | æ™®é€šå¼•ç”¨ | æ™ºèƒ½æŒ‡é’ˆ |
|------|---------|---------|
| **æ‰€æœ‰æƒ** | å€Ÿç”¨æ•°æ® | æ‹¥æœ‰æ•°æ® |
| **å…ƒæ•°æ®** | æ—  | æœ‰ï¼ˆå¦‚å¼•ç”¨è®¡æ•°ï¼‰ |
| **Drop** | ä¸é‡Šæ”¾å†…å­˜ | è‡ªåŠ¨é‡Šæ”¾å†…å­˜ |
| **å®ç°** | è¯­è¨€å†…ç½® | ç»“æ„ä½“ + Trait |

### æ™ºèƒ½æŒ‡é’ˆçš„æœ¬è´¨

æ™ºèƒ½æŒ‡é’ˆæ˜¯å®ç°äº† `Deref` å’Œ `Drop` trait çš„ç»“æ„ä½“ï¼š
- **Deref**: å…è®¸æ™ºèƒ½æŒ‡é’ˆåƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨
- **Drop**: ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨æ¸…ç†èµ„æº

---

## ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆï¼Ÿ

### Rust vs å…¶ä»–è¯­è¨€

**Java/Python/Go**:
- âœ… æœ‰åƒåœ¾å›æ”¶å™¨ï¼ˆGCï¼‰
- âœ… æ‰€æœ‰å¯¹è±¡éƒ½æ˜¯å¼•ç”¨
- âœ… è‡ªåŠ¨ç®¡ç†å†…å­˜
- âŒ è¿è¡Œæ—¶å¼€é”€
- âŒ ä¸å¯é¢„æµ‹çš„æš‚åœ

**Rust**:
- âœ… æ—  GCï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
- âœ… ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨
- âŒ éœ€è¦æ‰‹åŠ¨ç®¡ç†å†…å­˜
- âœ… æ™ºèƒ½æŒ‡é’ˆè®©æ‰‹åŠ¨ç®¡ç†å˜å¾—å®‰å…¨

---

## ğŸ“¦ Box\<T> - å †åˆ†é…

### åŸºæœ¬æ¦‚å¿µ

`Box<T>` æ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…æ•°æ®ã€‚

```rust
fn main() {
    let b = Box::new(5);  // åœ¨å †ä¸Šåˆ†é… i32
    println!("b = {}", b);
}  // b ç¦»å¼€ä½œç”¨åŸŸï¼Œå †å†…å­˜è¢«é‡Šæ”¾
```

### ä¸ Java å¯¹æ¯”

**Java**:
```java
// Java ä¸­ï¼Œå¯¹è±¡è‡ªåŠ¨åœ¨å †ä¸Šåˆ†é…
Integer num = new Integer(5);  // å †åˆ†é…
String str = new String("hello");  // å †åˆ†é…
```

**Rust**:
```rust
// Rust ä¸­ï¼ŒåŸºæœ¬ç±»å‹é»˜è®¤åœ¨æ ˆä¸Š
let num = 5;  // æ ˆä¸Š

// Box å¼ºåˆ¶åœ¨å †ä¸Šåˆ†é…
let num = Box::new(5);  // å †ä¸Š
```

### ä½¿ç”¨åœºæ™¯

#### 1. ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥çš„ç±»å‹

```rust
// âŒ é”™è¯¯ï¼šé€’å½’ç±»å‹å¤§å°æœªçŸ¥
// enum List {
//     Cons(i32, List),  // æ— é™é€’å½’
//     Nil,
// }

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ Box
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    let list = List::Cons(1,
        Box::new(List::Cons(2,
            Box::new(List::Cons(3,
                Box::new(List::Nil))))));
}
```

#### 2. è½¬ç§»å¤§å¯¹è±¡æ‰€æœ‰æƒ

```rust
struct LargeData {
    data: [u8; 10000],  // 10KB æ•°æ®
}

fn main() {
    let large = Box::new(LargeData { data: [0; 10000] });
    
    // åªç§»åŠ¨ Box æŒ‡é’ˆï¼ˆ8 å­—èŠ‚ï¼‰ï¼Œä¸æ‹·è´ 10KB æ•°æ®
    let moved = large;
}
```

#### 3. Trait å¯¹è±¡

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) { println!("æ±ªæ±ª"); }
}

fn main() {
    let animal: Box<dyn Animal> = Box::new(Dog);
    animal.speak();
}
```

---

## ğŸ”„ Rc\<T> - å¼•ç”¨è®¡æ•°ï¼ˆå•çº¿ç¨‹ï¼‰

### åŸºæœ¬æ¦‚å¿µ

`Rc<T>` (Reference Counted) å…è®¸å¤šä¸ªæ‰€æœ‰è€…å…±äº«æ•°æ®ï¼Œé€šè¿‡å¼•ç”¨è®¡æ•°ç®¡ç†å†…å­˜ã€‚

```rust
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&a));  // 1
    
    let b = Rc::clone(&a);  // å¼•ç”¨è®¡æ•° +1
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&a));  // 2
    
    {
        let c = Rc::clone(&a);  // å¼•ç”¨è®¡æ•° +1
        println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&a));  // 3
    }  // c ç¦»å¼€ä½œç”¨åŸŸï¼Œå¼•ç”¨è®¡æ•° -1
    
    println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&a));  // 2
}  // b, a ç¦»å¼€ä½œç”¨åŸŸï¼Œå¼•ç”¨è®¡æ•°å½’é›¶ï¼Œå†…å­˜é‡Šæ”¾
```

### ä¸ Java å¯¹æ¯”

**Java**:
```java
// Java ä¸­ï¼Œå¤šä¸ªå¼•ç”¨è‡ªåŠ¨æŒ‡å‘åŒä¸€å¯¹è±¡
List<String> list1 = new ArrayList<>();
List<String> list2 = list1;  // å…±äº«åŒä¸€å¯¹è±¡
List<String> list3 = list1;  // å…±äº«åŒä¸€å¯¹è±¡

list1.add("hello");
System.out.println(list2.size());  // 1
```

**Rust**:
```rust
use std::rc::Rc;

fn main() {
    let list1 = Rc::new(vec![1, 2, 3]);
    let list2 = Rc::clone(&list1);  // å…±äº«æ‰€æœ‰æƒ
    let list3 = Rc::clone(&list1);  // å…±äº«æ‰€æœ‰æƒ
    
    println!("é•¿åº¦: {}", list2.len());  // 3
}
```

### ä½¿ç”¨åœºæ™¯

#### å›¾ç»“æ„

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    next: Option<Rc<Node>>,
}

fn main() {
    let node3 = Rc::new(Node { value: 3, next: None });
    let node2 = Rc::new(Node { value: 2, next: Some(Rc::clone(&node3)) });
    let node1 = Rc::new(Node { value: 1, next: Some(Rc::clone(&node2)) });
    
    // node2 å’Œ node1 éƒ½æŒ‡å‘ node3
}
```

### é‡è¦ç‰¹æ€§

- âœ… å•çº¿ç¨‹ä½¿ç”¨
- âœ… å¤šä¸ªæ‰€æœ‰è€…
- âŒ ä¸å¯å˜ï¼ˆåªè¯»ï¼‰
- âš ï¸ å¯èƒ½é€ æˆå¾ªç¯å¼•ç”¨ï¼ˆå†…å­˜æ³„æ¼ï¼‰

---

## âš›ï¸ Arc\<T> - åŸå­å¼•ç”¨è®¡æ•°ï¼ˆå¤šçº¿ç¨‹ï¼‰

### åŸºæœ¬æ¦‚å¿µ

`Arc<T>` (Atomic Reference Counted) æ˜¯ `Rc<T>` çš„çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ã€‚

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} çœ‹åˆ°: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### ä¸ Java å¯¹æ¯”

**Java**:
```java
// Java ä¸­ï¼Œå¤šçº¿ç¨‹å…±äº«å¯¹è±¡
List<Integer> data = Collections.synchronizedList(new ArrayList<>());

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println(data);
    }).start();
}
```

**Rust**:
```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3]);
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        thread::spawn(move || {
            println!("{:?}", data_clone);
        });
    }
}
```

### Rc vs Arc

| ç‰¹æ€§ | Rc | Arc |
|------|-----|-----|
| **çº¿ç¨‹å®‰å…¨** | âŒ | âœ… |
| **æ€§èƒ½** | å¿« | ç¨æ…¢ï¼ˆåŸå­æ“ä½œï¼‰ |
| **ä½¿ç”¨åœºæ™¯** | å•çº¿ç¨‹ | å¤šçº¿ç¨‹ |

---

## ğŸ”“ RefCell\<T> - å†…éƒ¨å¯å˜æ€§

### åŸºæœ¬æ¦‚å¿µ

`RefCell<T>` å…è®¸åœ¨ä¸å¯å˜å¼•ç”¨å†…éƒ¨ä¿®æ”¹æ•°æ®ï¼Œå°†å€Ÿç”¨æ£€æŸ¥ä»ç¼–è¯‘æ—¶æ¨è¿Ÿåˆ°è¿è¡Œæ—¶ã€‚

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    // å¯å˜å€Ÿç”¨
    *data.borrow_mut() += 1;
    
    // ä¸å¯å˜å€Ÿç”¨
    println!("å€¼: {}", data.borrow());  // 6
}
```

### ä¸ Java å¯¹æ¯”

**Java**:
```java
// Java ä¸­ï¼Œfinal åªé™åˆ¶å¼•ç”¨ï¼Œä¸é™åˆ¶å†…å®¹
final List<String> list = new ArrayList<>();
list.add("hello");  // âœ… å¯ä»¥ä¿®æ”¹å†…å®¹
```

**Rust**:
```rust
use std::cell::RefCell;

fn main() {
    let list = RefCell::new(vec![]);
    list.borrow_mut().push("hello");  // âœ… å¯ä»¥ä¿®æ”¹
}
```

### è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    let r1 = data.borrow_mut();  // å¯å˜å€Ÿç”¨
    // let r2 = data.borrow();   // âŒ Panic! è¿åå€Ÿç”¨è§„åˆ™
}
```

### Rc + RefCell ç»„åˆ

```rust
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    // å¤šä¸ªæ‰€æœ‰è€… + å¯ä¿®æ”¹
    let data = Rc::new(RefCell::new(vec![1, 2, 3]));
    
    let data1 = Rc::clone(&data);
    let data2 = Rc::clone(&data);
    
    data1.borrow_mut().push(4);  // ä¿®æ”¹
    
    println!("{:?}", data2.borrow());  // [1, 2, 3, 4]
}
```

**Java ç­‰ä»·ä»£ç **:
```java
List<Integer> data = new ArrayList<>(Arrays.asList(1, 2, 3));
List<Integer> data1 = data;
List<Integer> data2 = data;

data1.add(4);
System.out.println(data2);  // [1, 2, 3, 4]
```

---

## ğŸ”’ Mutex\<T> - äº’æ–¥é”

### åŸºæœ¬æ¦‚å¿µ

`Mutex<T>` æä¾›çº¿ç¨‹å®‰å…¨çš„å†…éƒ¨å¯å˜æ€§ã€‚

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("ç»“æœ: {}", *counter.lock().unwrap());  // 10
}
```

### ä¸ Java å¯¹æ¯”

**Java**:
```java
class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
}

Counter counter = new Counter();
for (int i = 0; i < 10; i++) {
    new Thread(() -> counter.increment()).start();
}
```

**Rust**:
```rust
use std::sync::{Arc, Mutex};

let counter = Arc::new(Mutex::new(0));

for _ in 0..10 {
    let counter_clone = Arc::clone(&counter);
    thread::spawn(move || {
        *counter_clone.lock().unwrap() += 1;
    });
}
```

---

## ğŸ“Š æ™ºèƒ½æŒ‡é’ˆå¯¹æ¯”è¡¨

| æ™ºèƒ½æŒ‡é’ˆ | æ‰€æœ‰æƒ | å¯å˜æ€§ | çº¿ç¨‹å®‰å…¨ | ä½¿ç”¨åœºæ™¯ |
|---------|--------|--------|---------|---------|
| **Box\<T>** | å•ä¸€ | å¯å˜ | âŒ | å †åˆ†é…ã€é€’å½’ç±»å‹ |
| **Rc\<T>** | å¤šä¸ª | ä¸å¯å˜ | âŒ | å•çº¿ç¨‹å…±äº« |
| **Arc\<T>** | å¤šä¸ª | ä¸å¯å˜ | âœ… | å¤šçº¿ç¨‹å…±äº« |
| **RefCell\<T>** | å•ä¸€ | å¯å˜ | âŒ | å†…éƒ¨å¯å˜æ€§ |
| **Mutex\<T>** | å•ä¸€ | å¯å˜ | âœ… | çº¿ç¨‹å®‰å…¨ä¿®æ”¹ |

---

## ğŸ¨ å¸¸è§ç»„åˆ

### 1. Rc + RefCellï¼ˆå•çº¿ç¨‹å…±äº«å¯å˜ï¼‰

```rust
use std::rc::Rc;
use std::cell::RefCell;

struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let node = Rc::new(Node {
        value: 1,
        children: RefCell::new(vec![]),
    });
    
    let child = Rc::new(Node {
        value: 2,
        children: RefCell::new(vec![]),
    });
    
    node.children.borrow_mut().push(Rc::clone(&child));
}
```

### 2. Arc + Mutexï¼ˆå¤šçº¿ç¨‹å…±äº«å¯å˜ï¼‰

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            data_clone.lock().unwrap().push(i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("{:?}", data.lock().unwrap());
}
```

---

## ğŸ’¡ å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1: äºŒå‰æ ‘

```rust
use std::rc::Rc;
use std::cell::RefCell;

struct TreeNode {
    value: i32,
    left: Option<Rc<RefCell<TreeNode>>>,
    right: Option<Rc<RefCell<TreeNode>>>,
}

fn main() {
    let root = Rc::new(RefCell::new(TreeNode {
        value: 1,
        left: None,
        right: None,
    }));
    
    let left = Rc::new(RefCell::new(TreeNode {
        value: 2,
        left: None,
        right: None,
    }));
    
    root.borrow_mut().left = Some(Rc::clone(&left));
}
```

### ç¤ºä¾‹ 2: çº¿ç¨‹æ± å…±äº«é…ç½®

```rust
use std::sync::Arc;
use std::thread;

struct Config {
    max_connections: usize,
    timeout: u64,
}

fn main() {
    let config = Arc::new(Config {
        max_connections: 100,
        timeout: 30,
    });
    
    let mut handles = vec![];
    
    for i in 0..5 {
        let config_clone = Arc::clone(&config);
        let handle = thread::spawn(move || {
            println!("çº¿ç¨‹ {} ä½¿ç”¨é…ç½®: max={}, timeout={}",
                i, config_clone.max_connections, config_clone.timeout);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## ğŸ› å¸¸è§é™·é˜±

### 1. å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼

```rust
use std::rc::Rc;
use std::cell::RefCell;

struct Node {
    next: Option<Rc<RefCell<Node>>>,
}

fn main() {
    let a = Rc::new(RefCell::new(Node { next: None }));
    let b = Rc::new(RefCell::new(Node { next: None }));
    
    a.borrow_mut().next = Some(Rc::clone(&b));
    b.borrow_mut().next = Some(Rc::clone(&a));  // âŒ å¾ªç¯å¼•ç”¨
    
    // a å’Œ b æ°¸è¿œä¸ä¼šè¢«é‡Šæ”¾
}
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ `Weak<T>`

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    next: Option<Rc<RefCell<Node>>>,
    prev: Option<Weak<RefCell<Node>>>,  // ä½¿ç”¨ Weak
}
```

### 2. RefCell è¿è¡Œæ—¶ Panic

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    let r1 = data.borrow_mut();
    let r2 = data.borrow();  // âŒ Panic! è¿åå€Ÿç”¨è§„åˆ™
}
```

### 3. Mutex æ­»é”

```rust
use std::sync::Mutex;

fn main() {
    let data = Mutex::new(5);
    
    let _lock1 = data.lock().unwrap();
    let _lock2 = data.lock().unwrap();  // âŒ æ­»é”
}
```

---

## ğŸ“š æ€»ç»“

### é€‰æ‹©æŒ‡å—

| éœ€æ±‚ | é€‰æ‹© |
|------|------|
| å †åˆ†é… | `Box<T>` |
| å•çº¿ç¨‹å…±äº«ï¼ˆåªè¯»ï¼‰ | `Rc<T>` |
| å•çº¿ç¨‹å…±äº«ï¼ˆå¯å†™ï¼‰ | `Rc<RefCell<T>>` |
| å¤šçº¿ç¨‹å…±äº«ï¼ˆåªè¯»ï¼‰ | `Arc<T>` |
| å¤šçº¿ç¨‹å…±äº«ï¼ˆå¯å†™ï¼‰ | `Arc<Mutex<T>>` |

### ä¸ Java å¯¹æ¯”

| Java | Rust |
|------|------|
| `new Object()` | `Box::new()` |
| æ™®é€šå¼•ç”¨ | `Rc<T>` |
| çº¿ç¨‹å®‰å…¨å¼•ç”¨ | `Arc<T>` |
| å¯å˜å¯¹è±¡ | `RefCell<T>` |
| `synchronized` | `Mutex<T>` |

### æœ€ä½³å®è·µ

1. âœ… ä¼˜å…ˆä½¿ç”¨ `Box<T>` - æœ€ç®€å•
2. âœ… éœ€è¦å…±äº«æ—¶ç”¨ `Rc<T>` æˆ– `Arc<T>`
3. âœ… éœ€è¦ä¿®æ”¹æ—¶ç»„åˆ `RefCell<T>` æˆ– `Mutex<T>`
4. âš ï¸ æ³¨æ„å¾ªç¯å¼•ç”¨ - ä½¿ç”¨ `Weak<T>`
5. âš ï¸ é¿å…è¿‡åº¦ä½¿ç”¨ - å¢åŠ å¤æ‚åº¦

æŒæ¡æ™ºèƒ½æŒ‡é’ˆæ˜¯ç†è§£ Rust å†…å­˜ç®¡ç†çš„å…³é”®ï¼ğŸ¦€âœ¨

