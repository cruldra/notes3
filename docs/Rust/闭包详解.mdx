# Rust 闭包详解

## 闭包概念的溯源

### Lambda 演算：一切的起源

闭包和 lambda 表达式的概念最早可以追溯到 **Lambda 演算（Lambda Calculus）**，这是由数学家 **Alonzo Church** 在 **1930年代** 创造的数学系统。Lambda 演算可以说是最简单的"编程语言"，它只有两个基本操作：

1. **应用（Application）**：将一个表达式应用到另一个表达式，表示为 `f x`（可以理解为函数调用）
2. **抽象（Abstraction）**：使用希腊字母 λ（lambda）绑定一个符号，将表达式转换为期望参数的函数

例如：`λx.x + 2` 表示一个接受参数 `x` 并返回 `x + 2` 的匿名函数。

### 从 LISP 到 Scheme：闭包的诞生

- **1958年**：**John McCarthy** 基于 lambda 演算发明了 **LISP** 语言，这是世界上第二款高级编程语言（第一款是 FORTRAN），也是第一款函数式编程语言
- **1960年代**：**Peter J. Landin** 提出了 **闭包（Closure）** 的概念，同时他还创造了"语法糖"等术语
- **1975年**：**Gerald Jay Sussman** 和 **Guy Lewis Steele Jr.** 共同开发了 **Scheme** 语言，这是首个使用词法作用域的 LISP 方言，将闭包发扬光大

### FUNARG 问题：闭包诞生的背景

在早期的编程语言设计中，存在一个著名的 **FUNARG Problem**（函数参数问题），这个问题困扰了语言设计者十几年：

**问题场景**：当一个函数返回另一个持有自由变量的函数时，如何保存这些自由变量的值？

```
DEFINE F(X) TO BE
    LET G(Y) BE
        RETURN X^2 + Y^2
    END
    RETURN G
END

P ← F(3)  // P 引用了 X=3，但 F 已经执行完毕
```

在使用 **动态作用域** 的早期语言中，这个问题很难解决，因为：
- 函数通过符号表栈（symbol table stack）查找变量
- 当外层函数返回后，其局部变量就被销毁了
- 返回的内层函数无法再访问这些变量

**解决方案**：使用 **符号表树（symbol table tree）** 代替符号表栈，让返回的函数引用一个独立的环境，保存其捕获的变量。这种"函数 + 环境"的组合体，就是 **闭包**。

## Lambda 表达式 vs 闭包

### 它们是一个东西吗？

**不完全是！** 这是一个常见的误解。

### 核心区别

| 概念 | 定义 | 关系 |
|------|------|------|
| **Lambda 表达式** | 一种匿名函数的语法形式 | 是一种语法糖 |
| **闭包** | Lambda 表达式 + 捕获的环境 | 是运行时产生的对象 |

### 详细解释

1. **Lambda 表达式**：本质就是一个匿名函数
   ```rust
   // Rust 中的 lambda 表达式
   |x| x + 2
   
   // JavaScript 中的 lambda 表达式
   (x) => x + 2
   
   // Python 中的 lambda 表达式
   lambda x: x + 2
   ```

2. **闭包**：Lambda 表达式的闭包是定义在外部上下文（环境）中的特定符号集，它们给表达式中的自由变量赋值

### 开放表达式 vs 关闭表达式

- **开放表达式（Open Expression）**：包含自由变量（未绑定的变量）
  ```
  λx.x/y+2  // y 是自由变量
  ```

- **关闭表达式（Closed Expression）**：所有变量都被绑定，也称为 **组合子（Combinator）**
  ```
  λx.x+2  // 所有变量都被绑定
  ```

**闭包的作用**：将一个开放的 lambda 表达式转换为关闭的表达式，通过提供环境来绑定所有自由变量。

### 为什么会混淆？

许多编程语言（Java、C#、Go 等）的市场宣传将 lambda 表达式直接称为"闭包"，或者将实现词法作用域的技术称为"闭包"。这导致了概念的混淆。

**真相**：
- Lambda 表达式是 **语法层面** 的概念
- 闭包是 **语义层面** 的概念
- 闭包 = Lambda 表达式 + 捕获的环境

## Rust 中的闭包

### 基本语法

```rust
// 完整形式
|param1: i32, param2: i32| -> i32 {
    param1 + param2
}

// 简化形式（类型推导）
|x, y| x + y

// 单表达式形式
|x| x + 1
```

### 闭包的特点

1. **可以赋值给变量**
   ```rust
   let add = |x, y| x + y;
   ```

2. **可以捕获环境中的值**
   ```rust
   let x = 1;
   let add_x = |y| x + y;  // 捕获了 x
   ```

3. **类型推导**
   ```rust
   let sum = |x, y| x + y;
   let v = sum(1, 2);  // 编译器推导出 x, y 为 i32
   ```

### 三种 Fn 特征

Rust 将闭包分为三种类型，对应三种捕获变量的方式：

#### 1. FnOnce - 获取所有权

```rust
pub trait FnOnce<Args> {
    type Output;
    extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
}
```

- 参数类型：`self`（获取所有权）
- 特点：只能调用一次
- 使用场景：闭包会消耗捕获的变量

```rust
fn main() {
    let s = String::from("hello");
    let consume = || {
        println!("{}", s);
        drop(s);  // 消耗 s
    };
    
    consume();  // OK
    // consume();  // 错误：s 已被消耗
}
```

#### 2. FnMut - 可变借用

```rust
pub trait FnMut<Args>: FnOnce<Args> {
    extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
}
```

- 参数类型：`&mut self`（可变借用）
- 特点：可以多次调用，可以修改捕获的变量
- 使用场景：需要修改环境中的变量

```rust
fn main() {
    let mut count = 0;
    let mut increment = || {
        count += 1;
        println!("count: {}", count);
    };
    
    increment();  // count: 1
    increment();  // count: 2
}
```

#### 3. Fn - 不可变借用

```rust
pub trait Fn<Args>: FnMut<Args> {
    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
}
```

- 参数类型：`&self`（不可变借用）
- 特点：可以多次调用，不能修改捕获的变量
- 使用场景：只读访问环境中的变量

```rust
fn main() {
    let x = 5;
    let print_x = || println!("x: {}", x);
    
    print_x();  // x: 5
    print_x();  // x: 5
}
```

### 三种特征的关系

```
Fn ⊂ FnMut ⊂ FnOnce
```

- 所有闭包都实现了 `FnOnce`
- 不移出捕获变量所有权的闭包实现了 `FnMut`
- 不需要修改捕获变量的闭包实现了 `Fn`

### move 关键字

`move` 关键字强制闭包获取捕获变量的所有权：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    
    let handle = thread::spawn(move || {
        println!("vector: {:?}", v);
    });
    
    handle.join().unwrap();
    // println!("{:?}", v);  // 错误：v 已被移动
}
```

**注意**：使用 `move` 不代表闭包一定是 `FnOnce`，具体实现哪种特征取决于闭包如何使用捕获的变量。

## 闭包的实际应用

### 1. 简化代码

```rust
fn workout(intensity: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
    
    if intensity < 25 {
        println!("Do {} pushups!", expensive_closure(intensity));
        println!("Do {} situps!", expensive_closure(intensity));
    }
}
```

### 2. 迭代器适配器

```rust
let numbers = vec![1, 2, 3, 4, 5];
let doubled: Vec<i32> = numbers.iter()
    .map(|x| x * 2)
    .collect();
```

### 3. 作为函数参数

```rust
fn apply<F>(f: F, x: i32) -> i32 
where
    F: Fn(i32) -> i32,
{
    f(x)
}

let result = apply(|x| x + 1, 5);  // 6
```

### 4. 作为返回值

```rust
fn make_adder(n: i32) -> impl Fn(i32) -> i32 {
    move |x| x + n
}

let add_5 = make_adder(5);
println!("{}", add_5(10));  // 15
```

## 总结

### 概念层面

1. **闭包的历史**：起源于 1930 年代的 Lambda 演算，在 1960 年代由 Peter J. Landin 提出概念，在 1975 年由 Scheme 语言发扬光大

2. **Lambda vs 闭包**：
   - Lambda 表达式是匿名函数的语法形式
   - 闭包是 Lambda 表达式 + 捕获的环境
   - 闭包解决了 FUNARG 问题，使函数可以"记住"其定义时的环境

### Rust 实现层面

1. **三种 Fn 特征**：
   - `FnOnce`：获取所有权，只能调用一次
   - `FnMut`：可变借用，可多次调用并修改
   - `Fn`：不可变借用，可多次调用但不修改

2. **类型推导**：Rust 可以自动推导闭包的参数和返回值类型

3. **move 关键字**：强制闭包获取捕获变量的所有权

4. **实现的特征取决于使用方式**：闭包实现哪种 Fn 特征取决于它如何使用捕获的变量，而不是如何捕获它们

