# Rust ç”Ÿå‘½å‘¨æœŸè¯¦è§£

## ğŸ“š ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸï¼Ÿ

**ç”Ÿå‘½å‘¨æœŸï¼ˆLifetimeï¼‰** æ˜¯ Rust ä¸­æ¯ä¸ªå¼•ç”¨éƒ½å…·æœ‰çš„å±æ€§ï¼Œè¡¨ç¤ºå¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸèŒƒå›´ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- âœ… ç”Ÿå‘½å‘¨æœŸæ˜¯å¼•ç”¨æœ‰æ•ˆçš„ä½œç”¨åŸŸ
- âœ… å¤§éƒ¨åˆ†æ—¶å€™ç”Ÿå‘½å‘¨æœŸæ˜¯éšå¼çš„ï¼Œå¯ä»¥è¢«æ¨æ–­
- âœ… ç”Ÿå‘½å‘¨æœŸçš„ä¸»è¦ç›®æ ‡æ˜¯**é¿å…æ‚¬å‚å¼•ç”¨**
- âœ… ç”Ÿå‘½å‘¨æœŸæ˜¯ Rust æœ€ç‹¬ç‰¹çš„ç‰¹æ€§ä¹‹ä¸€
- âœ… ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œä¸å½±å“è¿è¡Œæ—¶æ€§èƒ½

### ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸï¼Ÿ

```rust
// âŒ æ‚¬å‚å¼•ç”¨ç¤ºä¾‹
fn main() {
    let r;
    
    {
        let x = 5;
        r = &x;  // x çš„å¼•ç”¨
    }  // x åœ¨è¿™é‡Œè¢«é”€æ¯
    
    println!("r: {}", r);  // é”™è¯¯ï¼r å¼•ç”¨äº†å·²é”€æ¯çš„ x
}
```

**ç¼–è¯‘é”™è¯¯**:
```
error[E0597]: `x` does not live long enough
```

---

## ğŸ” å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆBorrow Checkerï¼‰

Rust ç¼–è¯‘å™¨çš„å€Ÿç”¨æ£€æŸ¥å™¨é€šè¿‡æ¯”è¾ƒä½œç”¨åŸŸæ¥ç¡®ä¿æ‰€æœ‰å€Ÿç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

### ç¤ºä¾‹ï¼šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

**åˆ†æ**:
- `r` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'a`ï¼ˆå¤–éƒ¨ä½œç”¨åŸŸï¼‰
- `x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'b`ï¼ˆå†…éƒ¨ä½œç”¨åŸŸï¼‰
- `'b` < `'a`ï¼Œæ‰€ä»¥ `r` å¼•ç”¨çš„å¯¹è±¡æ¯”å¼•ç”¨æœ¬èº«å­˜æ´»æ—¶é—´çŸ­
- **ç¼–è¯‘å¤±è´¥**ï¼šè¢«å¼•ç”¨çš„å¯¹è±¡å¿…é¡»æ¯”å¼•ç”¨å­˜æ´»å¾—æ›´ä¹…

### æ­£ç¡®çš„ç¤ºä¾‹

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

**åˆ†æ**:
- `x` çš„ç”Ÿå‘½å‘¨æœŸ `'b` > `r` çš„ç”Ÿå‘½å‘¨æœŸ `'a`
- âœ… ç¼–è¯‘é€šè¿‡

---

## ğŸ¯ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•

### 1. åŸºæœ¬è¯­æ³•

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä»¥æ’‡å· `'` å¼€å¤´ï¼Œé€šå¸¸ä½¿ç”¨å°å†™å­—æ¯ï¼š

```rust
&i32        // æ™®é€šå¼•ç”¨
&'a i32     // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ 'a çš„å¼•ç”¨
&'a mut i32 // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸ 'a çš„å¯å˜å¼•ç”¨
```

**å‘½åè§„èŒƒ**:
- å¿…é¡»ä»¥ `'` å¼€å¤´
- é€šå¸¸å…¨å°å†™ä¸”å¾ˆçŸ­
- æœ€å¸¸ç”¨çš„æ˜¯ `'a`ã€`'b`ã€`'c`

### 2. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„å«ä¹‰

**é‡è¦**: ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨**ä¸ä¼šæ”¹å˜**å¼•ç”¨çš„å®é™…ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒåªæ˜¯æè¿°å¤šä¸ªå¼•ç”¨ä¹‹é—´çš„å…³ç³»ã€‚

```rust
// è¿™ä¸¤ä¸ªå¼•ç”¨å¿…é¡»æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
fn example<'a>(x: &'a i32, y: &'a i32) {
    // ...
}
```

---

## ğŸ“ å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### 1. ä¸ºä»€ä¹ˆéœ€è¦æ ‡æ³¨ï¼Ÿ

```rust
// âŒ ç¼–è¯‘å¤±è´¥
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**é”™è¯¯ä¿¡æ¯**:
```
error[E0106]: missing lifetime specifier
  --> src/main.rs:1:33
   |
1 | fn longest(x: &str, y: &str) -> &str {
   |                                 ^ expected named lifetime parameter
```

**åŸå› **: ç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›çš„å¼•ç”¨æ˜¯æ¥è‡ª `x` è¿˜æ˜¯ `y`ï¼Œæ— æ³•ç¡®å®šè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸã€‚

### 2. æ­£ç¡®çš„æ ‡æ³¨

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**å«ä¹‰**:
- å‚æ•° `x` å’Œ `y` çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯ `'a`
- è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯ `'a`
- è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ = `min(xçš„ç”Ÿå‘½å‘¨æœŸ, yçš„ç”Ÿå‘½å‘¨æœŸ)`

### 3. ä½¿ç”¨ç¤ºä¾‹

```rust
fn main() {
    let string1 = String::from("long string is long");
    
    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }  // âœ… result åœ¨è¿™é‡Œç»“æŸï¼Œæ²¡é—®é¢˜
}
```

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }  // string2 åœ¨è¿™é‡Œè¢«é”€æ¯
    
    println!("The longest string is {}", result);  // âŒ é”™è¯¯ï¼
}
```

**é”™è¯¯åŸå› **: `result` çš„ç”Ÿå‘½å‘¨æœŸå—é™äº `string2`ï¼Œä½† `string2` å·²ç»è¢«é”€æ¯ã€‚

---

## ğŸ—ï¸ ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### 1. åŸºæœ¬ç”¨æ³•

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

**å«ä¹‰**: `ImportantExcerpt` å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å…¶ `part` å­—æ®µå¼•ç”¨çš„æ•°æ®ã€‚

### 2. å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
struct DoubleRef<'a, 'b> {
    r: &'a i32,
    s: &'b i32,
}

fn main() {
    let x = 5;
    let y = 10;
    
    let double = DoubleRef {
        r: &x,
        s: &y,
    };
}
```

---

## ğŸ¨ ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼ˆLifetime Elisionï¼‰

ç¼–è¯‘å™¨åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼Œæ— éœ€æ˜¾å¼æ ‡æ³¨ã€‚

### ä¸‰å¤§çœç•¥è§„åˆ™

#### è§„åˆ™ 1: æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ

```rust
// ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ä¸ºï¼š
fn foo<'a>(x: &'a i32) {}

// ä¸¤ä¸ªå‚æ•°ï¼š
fn foo<'a, 'b>(x: &'a i32, y: &'b i32) {}
```

#### è§„åˆ™ 2: åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œèµ‹ç»™æ‰€æœ‰è¾“å‡º

```rust
// è‡ªåŠ¨æ¨æ–­ä¸ºï¼š
fn foo<'a>(x: &'a i32) -> &'a i32 {}
```

#### è§„åˆ™ 3: æ–¹æ³•ä¸­ï¼Œself çš„ç”Ÿå‘½å‘¨æœŸèµ‹ç»™æ‰€æœ‰è¾“å‡º

```rust
impl<'a> MyStruct<'a> {
    // è‡ªåŠ¨æ¨æ–­ä¸ºï¼š
    fn method<'b>(&'a self, other: &'b str) -> &'a str {}
}
```

### ç¤ºä¾‹ï¼šfirst_word å‡½æ•°

```rust
// ä¸éœ€è¦æ˜¾å¼æ ‡æ³¨
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

// ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ä¸ºï¼š
fn first_word<'a>(s: &'a str) -> &'a str {
    // ...
}
```

**åº”ç”¨è§„åˆ™**:
1. è§„åˆ™ 1: `s` è·å¾—ç”Ÿå‘½å‘¨æœŸ `'a`
2. è§„åˆ™ 2: åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œèµ‹ç»™è¾“å‡º
3. ç»“æœ: `fn first_word<'a>(s: &'a str) -> &'a str`

---

## ğŸ”§ æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### 1. åŸºæœ¬æ–¹æ³•

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3  // è¿”å›å€¼ä¸æ˜¯å¼•ç”¨ï¼Œæ— éœ€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    }
}
```

### 2. è¿”å›å¼•ç”¨çš„æ–¹æ³•

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part  // è¿”å› self çš„å¼•ç”¨
    }
}
```

**åº”ç”¨çœç•¥è§„åˆ™**:
1. è§„åˆ™ 1: `&self` å’Œ `announcement` å„æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
2. è§„åˆ™ 3: è¿”å›å€¼è·å¾— `&self` çš„ç”Ÿå‘½å‘¨æœŸ
3. ç»“æœ: æ— éœ€æ˜¾å¼æ ‡æ³¨

---

## ğŸŒŸ 'static ç”Ÿå‘½å‘¨æœŸ

### 1. ä»€ä¹ˆæ˜¯ 'staticï¼Ÿ

`'static` è¡¨ç¤ºå¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆã€‚

```rust
let s: &'static str = "I have a static lifetime.";
```

**ç‰¹ç‚¹**:
- å­—ç¬¦ä¸²å­—é¢é‡éƒ½æ˜¯ `'static`
- æ•°æ®å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­
- å§‹ç»ˆå¯ç”¨

### 2. ä½•æ—¶ä½¿ç”¨ï¼Ÿ

```rust
// âœ… å­—ç¬¦ä¸²å­—é¢é‡
const GREETING: &'static str = "Hello, world!";

// âŒ ä¸è¦æ»¥ç”¨
fn bad_example() -> &'static str {
    let s = String::from("hello");
    // é”™è¯¯ï¼ä¸èƒ½è¿”å› 'static å¼•ç”¨
}
```

**è­¦å‘Š**: çœ‹åˆ°ç¼–è¯‘å™¨å»ºè®®ä½¿ç”¨ `'static` æ—¶ï¼Œå…ˆæ€è€ƒæ˜¯å¦çœŸçš„éœ€è¦ï¼Œé€šå¸¸æ˜¯å…¶ä»–é—®é¢˜å¯¼è‡´çš„ã€‚

---

## ğŸš€ é«˜çº§ç‰¹æ€§

### 1. ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rust
// 'a: 'b è¡¨ç¤º 'a è‡³å°‘è¦æ´»å¾—è·Ÿ 'b ä¸€æ ·ä¹…
struct Ref<'a, 'b: 'a> {
    x: &'a i32,
    y: &'b i32,
}
```

### 2. T: 'a çº¦æŸ

```rust
// T å¿…é¡»æ¯” 'a æ´»å¾—ä¹…
struct Wrapper<'a, T: 'a> {
    value: &'a T,
}

// Rust 1.31+ å¯ä»¥çœç•¥
struct Wrapper<'a, T> {
    value: &'a T,
}
```

### 3. å¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°

```rust
fn complex<'a, 'b>(x: &'a str, y: &'b str) -> &'a str
where
    'b: 'a,  // 'b å¿…é¡»æ¯” 'a æ´»å¾—ä¹…
{
    x
}
```

---

## ğŸ’¡ å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1: å­—ç¬¦ä¸²åˆ†å‰²

```rust
fn split_first_word<'a>(s: &'a str) -> (&'a str, &'a str) {
    match s.find(' ') {
        Some(pos) => (&s[..pos], &s[pos + 1..]),
        None => (s, ""),
    }
}

fn main() {
    let sentence = String::from("Hello world");
    let (first, rest) = split_first_word(&sentence);
    println!("First: {}, Rest: {}", first, rest);
}
```

### ç¤ºä¾‹ 2: ç¼“å­˜ç»“æ„

```rust
struct Cache<'a> {
    data: &'a str,
    computed: Option<String>,
}

impl<'a> Cache<'a> {
    fn new(data: &'a str) -> Self {
        Cache {
            data,
            computed: None,
        }
    }
    
    fn get_or_compute(&mut self) -> &str {
        if self.computed.is_none() {
            self.computed = Some(self.data.to_uppercase());
        }
        self.computed.as_ref().unwrap()
    }
}
```

### ç¤ºä¾‹ 3: æ³›å‹ + Trait + ç”Ÿå‘½å‘¨æœŸ

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest_with_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    println!("The longest string is {}", result);
}
```

---

## ğŸ“š æ€»ç»“

### ç”Ÿå‘½å‘¨æœŸçš„æ ¸å¿ƒä»·å€¼

1. **å†…å­˜å®‰å…¨** - é˜²æ­¢æ‚¬å‚å¼•ç”¨
2. **ç¼–è¯‘æ—¶æ£€æŸ¥** - é›¶è¿è¡Œæ—¶å¼€é”€
3. **æ˜ç¡®å…³ç³»** - æ¸…æ™°è¡¨è¾¾å¼•ç”¨ä¹‹é—´çš„å…³ç³»
4. **è‡ªåŠ¨æ¨æ–­** - å¤§éƒ¨åˆ†æƒ…å†µæ— éœ€æ˜¾å¼æ ‡æ³¨

### æœ€ä½³å®è·µ

âœ… **ä¼˜å…ˆä¾èµ–çœç•¥è§„åˆ™** - è®©ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­  
âœ… **åªåœ¨å¿…è¦æ—¶æ ‡æ³¨** - ç¼–è¯‘å™¨æŠ¥é”™æ—¶å†æ·»åŠ   
âœ… **ä½¿ç”¨æœ‰æ„ä¹‰çš„åç§°** - `'a`ã€`'b` å¯¹ç®€å•æƒ…å†µè¶³å¤Ÿ  
âœ… **é¿å…è¿‡åº¦ä½¿ç”¨ 'static** - é€šå¸¸æœ‰æ›´å¥½çš„è§£å†³æ–¹æ¡ˆ  
âœ… **ç†è§£å€Ÿç”¨æ£€æŸ¥å™¨** - å®ƒæ˜¯ä½ çš„æœ‹å‹ï¼Œä¸æ˜¯æ•Œäºº  

### å¸¸è§é”™è¯¯

âŒ **è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨**
```rust
fn bad() -> &str {
    let s = String::from("hello");
    &s  // é”™è¯¯ï¼s ä¼šè¢«é”€æ¯
}
```

âŒ **ç”Ÿå‘½å‘¨æœŸä¸åŒ¹é…**
```rust
fn bad<'a>(x: &'a str) -> &'a str {
    let s = String::from("hello");
    &s  // é”™è¯¯ï¼è¿”å›å€¼ç”Ÿå‘½å‘¨æœŸä¸åŒ¹é…
}
```

---

## ğŸ“ é«˜çº§ä¸»é¢˜

### 1. NLL (Non-Lexical Lifetime)

**ä¼ ç»Ÿè§„åˆ™**: å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä»å€Ÿç”¨å¼€å§‹æŒç»­åˆ°ä½œç”¨åŸŸç»“æŸã€‚

**NLL è§„åˆ™** (Rust 1.31+): å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä»å€Ÿç”¨å¼€å§‹ï¼ŒæŒç»­åˆ°**æœ€åä¸€æ¬¡ä½¿ç”¨**ã€‚

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // r1 å’Œ r2 çš„ç”Ÿå‘½å‘¨æœŸåœ¨è¿™é‡Œç»“æŸï¼ˆæœ€åä¸€æ¬¡ä½¿ç”¨ï¼‰

    let r3 = &mut s;  // âœ… ç°åœ¨å¯ä»¥äº†ï¼
    println!("{}", r3);
}
```

**ä¼ ç»Ÿè§„åˆ™ä¸‹**: ä¸Šè¿°ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸º `r1` å’Œ `r2` ä¼šæŒç»­åˆ° `main` ç»“æŸã€‚

**NLL è§„åˆ™ä¸‹**: âœ… ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸º `r1` å’Œ `r2` åœ¨ `println!` åå°±ä¸å†ä½¿ç”¨ã€‚

#### NLL çš„è¯¦ç»†ç¤ºä¾‹

```rust
let mut u = 0i32;
let mut v = 1i32;
let mut w = 2i32;

// a æœ‰ä¸‰æ®µç”Ÿå‘½å‘¨æœŸï¼šÎ±, Î², Î³
let mut a = &mut u;     // --+ Î±. lifetime of `&mut u`
use(a);                 //   |
*a = 3;                 // <-+ Î± ç»“æŸ

a = &mut v;             // --+ Î². lifetime of `&mut v`
use(a);                 //   |
*a = 4;                 // <-+ Î² ç»“æŸ

a = &mut w;             // --+ Î³. lifetime of `&mut w`
use(a);                 //   |
*a = 5;                 // <-+ Î³ ç»“æŸ
```

### 2. Reborrow (å†å€Ÿç”¨)

å†å€Ÿç”¨å…è®¸ä»ä¸€ä¸ªå¯å˜å¼•ç”¨åˆ›å»ºæ–°çš„å¼•ç”¨ï¼Œè€Œä¸è¿åå€Ÿç”¨è§„åˆ™ã€‚

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;

    // å†å€Ÿç”¨ï¼šä» r åˆ›å»ºä¸å¯å˜å¼•ç”¨
    let rr: &Point = &*r;

    println!("{:?}", rr);  // rr æœ€åä¸€æ¬¡ä½¿ç”¨

    // rr çš„ç”Ÿå‘½å‘¨æœŸç»“æŸåï¼Œå¯ä»¥ç»§ç»­ä½¿ç”¨ r
    r.move_to(10, 10);
    println!("{:?}", r);
}
```

**å…³é”®ç‚¹**:
- `rr` æ˜¯å¯¹ `r` çš„å†å€Ÿç”¨
- åœ¨ `rr` çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œä¸èƒ½ä½¿ç”¨åŸå§‹å€Ÿç”¨ `r`
- `rr` ç»“æŸåï¼Œ`r` å¯ä»¥ç»§ç»­ä½¿ç”¨

#### é”™è¯¯ç¤ºä¾‹

```rust
fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;
    let rr: &Point = &*r;

    r.move_to(10, 10);  // âŒ é”™è¯¯ï¼åœ¨ rr çš„ç”Ÿå‘½å‘¨æœŸå†…ä½¿ç”¨äº† r

    println!("{:?}", rr);
}
```

### 3. æ— ç•Œç”Ÿå‘½å‘¨æœŸ (Unbounded Lifetime)

åœ¨ `unsafe` ä»£ç ä¸­ï¼Œè§£å¼•ç”¨è£¸æŒ‡é’ˆä¼šäº§ç”Ÿæ— ç•Œç”Ÿå‘½å‘¨æœŸã€‚

```rust
fn f<'a, T>(x: *const T) -> &'a T {
    unsafe {
        &*x  // 'a æ˜¯å‡­ç©ºäº§ç”Ÿçš„ï¼Œæ²¡æœ‰ä»»ä½•çº¦æŸ
    }
}
```

**ç‰¹ç‚¹**:
- æ— ç•Œç”Ÿå‘½å‘¨æœŸå¯ä»¥æ˜¯ä»»æ„å¤§å°
- æ¯” `'static` æ›´å¼ºå¤§
- `&'unbounded &'a T` ä¼šè¢«è§†ä¸º `&'a &'a T`

**è­¦å‘Š**: åº”å°½é‡é¿å…æ— ç•Œç”Ÿå‘½å‘¨æœŸï¼Œä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ã€‚

### 4. é—­åŒ…ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸè§„åˆ™ä¸å‡½æ•°ä¸åŒï¼Œæ›´åŠ ä¸¥æ ¼ã€‚

```rust
// âœ… å‡½æ•°å¯ä»¥è‡ªåŠ¨æ¨æ–­
fn fn_elision(x: &i32) -> &i32 { x }

// âŒ é—­åŒ…æ— æ³•è‡ªåŠ¨æ¨æ–­
let closure_elision = |x: &i32| -> &i32 { x };  // ç¼–è¯‘é”™è¯¯ï¼
```

**é”™è¯¯ä¿¡æ¯**:
```
error: lifetime may not live long enough
```

**åŸå› **: é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸåˆ†æ•£åœ¨å‚æ•°å’Œé—­åŒ…ä½“ä¸­ï¼Œç¼–è¯‘å™¨éš¾ä»¥æ¨æ–­ã€‚

#### è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ Fn trait

```rust
fn main() {
    let closure_elision = fun(|x: &i32| -> &i32 { x });
    assert_eq!(*closure_elision(&45), 45);
}

fn fun<T, F: Fn(&T) -> &T>(f: F) -> F {
    f
}
```

### 5. ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„é«˜çº§ç”¨æ³•

#### ç¤ºä¾‹ï¼šå¤æ‚çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»

```rust
struct Interface<'a> {
    manager: &'a mut Manager<'a>,
}

impl<'a> Interface<'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str,
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    // âŒ é”™è¯¯çš„å®ç°
    pub fn get_interface_bad(&'a mut self) -> Interface {
        Interface {
            manager: &mut self.manager,
        }
    }

    // âœ… æ­£ç¡®çš„å®ç°ï¼šä½¿ç”¨ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
    pub fn get_interface<'b>(&'b mut self) -> Interface<'b, 'a>
    where
        'a: 'b,
    {
        Interface {
            manager: &mut self.manager,
        }
    }
}
```

**é—®é¢˜**: å¦‚æœ `get_interface` çš„å‚æ•°ç”Ÿå‘½å‘¨æœŸä¸ `List<'a>` ç›¸åŒï¼Œé‚£ä¹ˆå€Ÿç”¨ä¼šæŒç»­åˆ° `List` çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸã€‚

**è§£å†³**: å¼•å…¥æ–°çš„ç”Ÿå‘½å‘¨æœŸå‚æ•° `'b`ï¼Œä½¿å€Ÿç”¨åªåœ¨æ–¹æ³•è°ƒç”¨æœŸé—´æœ‰æ•ˆã€‚

---

## ğŸ› å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

### é™·é˜± 1: ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥å™¨ä¸å¤Ÿèªæ˜

```rust
#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&mut self) -> &Self {
        &*self
    }
    fn share(&self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();  // âŒ é”™è¯¯ï¼
    println!("{:?}", loan);
}
```

**é”™è¯¯åŸå› **:
- `mutate_and_share` çš„å‚æ•°å’Œè¿”å›å€¼æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
- `loan` çš„ç”Ÿå‘½å‘¨æœŸæŒç»­åˆ° `println!`
- å› æ­¤ `&mut self` çš„å€Ÿç”¨ä¹ŸæŒç»­åˆ° `println!`
- å¯¼è‡´ `foo.share()` æ— æ³•å€Ÿç”¨

**è§£å†³æ–¹æ¡ˆ**: ç›®å‰åªèƒ½ä¿®æ”¹ä»£ç ç»“æ„ï¼ŒæœŸå¾…ç¼–è¯‘å™¨æœªæ¥æ›´æ™ºèƒ½ã€‚

### é™·é˜± 2: HashMap çš„ get_mut é—®é¢˜

```rust
use std::collections::HashMap;
use std::hash::Hash;

fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V
where
    K: Clone + Eq + Hash,
    V: Default,
{
    match map.get_mut(&key) {
        Some(value) => value,  // âŒ ç¼–è¯‘å™¨è®¤ä¸ºå€Ÿç”¨æŒç»­åˆ° match ç»“æŸ
        None => {
            map.insert(key.clone(), V::default());  // é”™è¯¯ï¼
            map.get_mut(&key).unwrap()
        }
    }
}
```

**é”™è¯¯åŸå› **: ç¼–è¯‘å™¨è®¤ä¸º `map.get_mut(&key)` çš„å€Ÿç”¨æŒç»­åˆ°æ•´ä¸ª `match` å—ç»“æŸã€‚

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ `entry` API

```rust
fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V
where
    K: Clone + Eq + Hash,
    V: Default,
{
    map.entry(key).or_insert_with(V::default)
}
```

### é™·é˜± 3: è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨

```rust
// âŒ æ°¸è¿œä¸è¦è¿™æ ·åš
fn dangle<'a>() -> &'a str {
    let s = String::from("hello");
    &s  // é”™è¯¯ï¼s ä¼šè¢«é”€æ¯
}
```

**è§£å†³æ–¹æ¡ˆ**: è¿”å›æ‰€æœ‰æƒ

```rust
// âœ… è¿”å› String è€Œä¸æ˜¯ &str
fn no_dangle() -> String {
    String::from("hello")
}
```

---

## ğŸ“Š ç”Ÿå‘½å‘¨æœŸé€ŸæŸ¥è¡¨

| åœºæ™¯ | è¯­æ³• | è¯´æ˜ |
|------|------|------|
| **åŸºæœ¬å¼•ç”¨** | `&'a T` | ç”Ÿå‘½å‘¨æœŸä¸º 'a çš„å¼•ç”¨ |
| **å¯å˜å¼•ç”¨** | `&'a mut T` | ç”Ÿå‘½å‘¨æœŸä¸º 'a çš„å¯å˜å¼•ç”¨ |
| **å‡½æ•°å‚æ•°** | `fn foo<'a>(x: &'a i32)` | æ˜¾å¼ç”Ÿå‘½å‘¨æœŸå‚æ•° |
| **å¤šä¸ªå‚æ•°** | `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)` | ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ |
| **è¿”å›å¼•ç”¨** | `fn foo<'a>(...) -> &'a T` | è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ |
| **ç»“æ„ä½“** | `struct S<'a> { r: &'a i32 }` | åŒ…å«å¼•ç”¨çš„ç»“æ„ä½“ |
| **impl å—** | `impl<'a> S<'a> { ... }` | ä¸ºå¸¦ç”Ÿå‘½å‘¨æœŸçš„ç»“æ„ä½“å®ç°æ–¹æ³• |
| **ç”Ÿå‘½å‘¨æœŸçº¦æŸ** | `'a: 'b` | 'a è‡³å°‘è¦æ´»å¾—è·Ÿ 'b ä¸€æ ·ä¹… |
| **ç±»å‹çº¦æŸ** | `T: 'a` | T å¿…é¡»æ¯” 'a æ´»å¾—ä¹… |
| **é™æ€ç”Ÿå‘½å‘¨æœŸ** | `'static` | æ•´ä¸ªç¨‹åºæœŸé—´æœ‰æ•ˆ |
| **åŒ¿åç”Ÿå‘½å‘¨æœŸ** | `'_` | è®©ç¼–è¯‘å™¨æ¨æ–­ |

---

## ğŸ¯ å®ç”¨æŠ€å·§

### æŠ€å·§ 1: ä½¿ç”¨ '_ ç®€åŒ–ä»£ç 

```rust
// æ—§å†™æ³•
impl<'a> Reader for BufReader<'a> {
    // ...
}

// æ–°å†™æ³• (Rust 2018+)
impl Reader for BufReader<'_> {
    // ...
}
```

### æŠ€å·§ 2: ä¼˜å…ˆä½¿ç”¨çœç•¥è§„åˆ™

```rust
// âŒ è¿‡åº¦æ ‡æ³¨
fn first_word<'a>(s: &'a str) -> &'a str {
    // ...
}

// âœ… è®©ç¼–è¯‘å™¨æ¨æ–­
fn first_word(s: &str) -> &str {
    // ...
}
```

### æŠ€å·§ 3: ä½¿ç”¨ where å­å¥æé«˜å¯è¯»æ€§

```rust
// âŒ éš¾ä»¥é˜…è¯»
fn complex<'a, 'b, T: Display + Clone, U: Clone + Debug>(
    x: &'a T,
    y: &'b U,
) -> &'a T
where
    'b: 'a,
{
    // ...
}

// âœ… æ¸…æ™°æ˜“è¯»
fn complex<'a, 'b, T, U>(x: &'a T, y: &'b U) -> &'a T
where
    T: Display + Clone,
    U: Clone + Debug,
    'b: 'a,
{
    // ...
}
```

---

## ğŸ“š æ€»ç»“

ç”Ÿå‘½å‘¨æœŸæ˜¯ Rust æœ€å¼ºå¤§ä¹Ÿæœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼š

### æ ¸å¿ƒè¦ç‚¹

1. **é˜²æ­¢æ‚¬å‚å¼•ç”¨** - ç¼–è¯‘æ—¶ä¿è¯å†…å­˜å®‰å…¨
2. **é›¶è¿è¡Œæ—¶å¼€é”€** - æ‰€æœ‰æ£€æŸ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆ
3. **è‡ªåŠ¨æ¨æ–­** - å¤§éƒ¨åˆ†æƒ…å†µæ— éœ€æ˜¾å¼æ ‡æ³¨
4. **æ˜ç¡®å…³ç³»** - æ¸…æ™°è¡¨è¾¾å¼•ç”¨ä¹‹é—´çš„ä¾èµ–

### å­¦ä¹ è·¯å¾„

1. âœ… ç†è§£å€Ÿç”¨æ£€æŸ¥å™¨çš„å·¥ä½œåŸç†
2. âœ… æŒæ¡ä¸‰å¤§ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
3. âœ… å­¦ä¼šåœ¨å‡½æ•°å’Œç»“æ„ä½“ä¸­æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
4. âœ… äº†è§£ NLL å’Œ Reborrow ç­‰é«˜çº§ç‰¹æ€§
5. âœ… å®è·µä¸­ç§¯ç´¯ç»éªŒ

æŒæ¡ç”Ÿå‘½å‘¨æœŸæ˜¯æˆä¸º Rust é«˜æ‰‹çš„å…³é”®ï¼ğŸ¦€âœ¨

