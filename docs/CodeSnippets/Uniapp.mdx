## é¡¹ç›®ç»“æ„

```text
ğŸ“¦ projectRoot/
â”œâ”€â”€ ğŸ“‚ src/
â”‚   â”œâ”€â”€ ğŸ“‚ components/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ Component1.tsx
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ Component2.tsx
â”‚   â”‚   â””â”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“‚ pages/
â”‚   â”‚   â””â”€â”€ ğŸ“‚ [resource]/
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ page1.vue
â”‚   â”‚       â””â”€â”€ ğŸ“„ page2.vue
â”‚   â”œâ”€â”€ ğŸ“‚ subpkg/
â”‚   â”‚   â””â”€â”€ ğŸ“‚ [resource]/
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ page1.vue
â”‚   â”‚       â””â”€â”€ ğŸ“„ page2.vue
â”‚   â”œâ”€â”€ ğŸ“‚ services/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ [Resource]Service.ts
â”‚   â”‚   â””â”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“‚ stores/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ [Resource]Store.ts
â”‚   â”‚   â””â”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“‚ types/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ [Resource].ts
â”‚   â”‚   â””â”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“‚ utils/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ util1.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ util2.ts
â”‚   â”‚   â””â”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“„ App.vue
â”‚   â”œâ”€â”€ ğŸ“„ main.ts
â”‚   â”œâ”€â”€ ğŸ“„ manifest.json
â”‚   â””â”€â”€ ğŸ“„ pages.json
â”œâ”€â”€ ğŸ“„ .env
â”œâ”€â”€ ğŸ“„ .env.development
â”œâ”€â”€ ğŸ“„ .env.production
â”œâ”€â”€ ğŸ“„ index.html
â”œâ”€â”€ ğŸ“¦ package.json
â”œâ”€â”€ âš™ï¸ tsconfig.json
â”œâ”€â”€ âš™ï¸ vite.config.mjs
â””â”€â”€ ğŸ¨ unocss.config.ts
```

## æœåŠ¡ç±»

æœåŠ¡ç±»ç”¨äºå’Œåç«¯äº¤äº’,é‡‡ç”¨`retrofit`æ ¼å¼

```ts
import {createApi, DefaultApiImpl, Get, Path, Query} from "@dongjak-extensions/http-client";
import {request} from "@/utils/http.ts";
import type {ResponsePayloads} from "@/types/common.ts";
import type {Course} from "@/types/course.ts";

class CourseService extends DefaultApiImpl {


    /**
     * æŸ¥è¯¢è¯¾ç¨‹åˆ—è¡¨
     * @param type  ç±»å‹
     * @param offset æ•°æ®åç§»é‡
     * @param limit æ•°æ®é•¿åº¦
     */
    @Get('/courses')
    getCourses(@Query("type") type: string, @Query("offset") offset: number, @Query("limit") limit: number): Promise<ResponsePayloads<Array<Course>>> {
        return Promise.resolve() as any
    }

    /**
     * æŸ¥è¯¢æ¨èè¯¾ç¨‹
     */
    @Get('/courses/recommended')
    getRecommendedCourses(): Promise<ResponsePayloads<Array<Course>>> {
        return Promise.resolve() as any
    }

    /**
     * æŸ¥è¯¢è¯¾ç¨‹è¯¦æƒ…
     * @param id è¯¾ç¨‹ID
     */
    @Get('/courses/:id')
    getCourseDetail(@Path("id") id: string): Promise<ResponsePayloads<Course>> {
        return Promise.resolve() as any
    }

    /**
     * æŸ¥è¯¢å·²è´­ä¹°çš„è¯¾ç¨‹
     */
    @Get('/courses/my/purchased')
    getPurchasedCourses(): Promise<ResponsePayloads<Array<Course>>> {
        return Promise.resolve() as any
    }


}

export const courseService = createApi(CourseService, request)
```

## é¡µé¢

### ä¸Šæ‹‰åŠ è½½ä¸‹æ‹‰åˆ·æ–°

```html
<template>
  <scroll-view
    class="scroll-container"
    scroll-y
    @scrolltolower="onLoadMore"
    @refresherrefresh="onRefresh"
    :refresher-enabled="true"
    :refresher-triggered="isRefreshing"
  >
    <div class="list">
      <!-- åˆ—è¡¨å†…å®¹ -->
      <div class="item" v-for="(item, index) in list" :key="index">
        {{ item.title }}
      </div>

      <!-- åŠ è½½çŠ¶æ€ -->
      <div v-if="list.length" class="loading-text">
        {{ pageParams.hasMore ? 'æ­£åœ¨åŠ è½½...' : 'æ²¡æœ‰æ›´å¤šäº†' }}
      </div>
    </div>
  </scroll-view>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { listApi } from '@/services'

// åˆ—è¡¨æ•°æ®
const list = ref([])

// åˆ·æ–°çŠ¶æ€
const isRefreshing = ref(false)

// åˆ†é¡µå‚æ•°
const pageParams = ref({
  offset: 0,
  limit: 10,
  isLoading: false,
  hasMore: true
})

// è·å–åˆ—è¡¨æ•°æ®
const getList = async () => {
  if (!pageParams.value.hasMore || pageParams.value.isLoading) return
  pageParams.value.isLoading = true

  try {
    const res = await listApi.getList(pageParams.value.offset, pageParams.value.limit)

    if (pageParams.value.offset === 0) {
      list.value = res.data || []
    } else {
      list.value.push(...(res.data || []))
    }

    pageParams.value.hasMore = (res.data || []).length === pageParams.value.limit
    pageParams.value.offset += pageParams.value.limit
  } finally {
    pageParams.value.isLoading = false
  }
}

// åˆ·æ–°
const onRefresh = async () => {
  isRefreshing.value = true
  try {
    pageParams.value.offset = 0
    pageParams.value.hasMore = true
    await getList()
  } finally {
    isRefreshing.value = false
  }
}

// åŠ è½½æ›´å¤š
const onLoadMore = async () => {
  await getList()
}
</script>

<style scoped>
.scroll-container {
  height: 100vh;
}

.loading-text {
  text-align: center;
  font-size: 24rpx;
  color: #999;
  padding: 20rpx 0;
}
</style>
```

### websocket

```html
<template>
  <div class="chat-container">
    <!-- èŠå¤©æ¶ˆæ¯åˆ—è¡¨ -->
    <scroll-view
      class="message-list"
      scroll-y
      :scroll-top="scrollTop"
      :scroll-with-animation="true"
    >
      <div class="message-inner">
        <div v-for="(msg, index) in messageList" :key="index"
             :class="['message', msg.type === 'user' ? 'user' : 'ai']">
          {{ msg.content }}
        </div>
        <!-- ç”Ÿæˆä¸­æç¤º -->
        <div v-if="isGenerating" class="generating">
          AIæ­£åœ¨æ€è€ƒ...
          <div class="stop-btn" @tap="stopGenerate">åœæ­¢</div>
        </div>
      </div>
    </scroll-view>

    <!-- è¾“å…¥æ¡† -->
    <div class="input-box">
      <input
        v-model="inputText"
        class="input"
        placeholder="è¯·è¾“å…¥å†…å®¹..."
      />
      <button @tap="sendMessage" class="send-btn">å‘é€</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick } from 'vue'

const messageList = ref<Array<{type: string, content: string}>>([])
const inputText = ref('')
const scrollTop = ref(0)
const isGenerating = ref(false)
const ws = ref<any>(null)
const currentTaskId = ref('')

// è¿æ¥WebSocket
function connectWebSocket() {
  ws.value = uni.connectSocket({
    url: `${import.meta.env.VITE_WS_URL}ws/chat/1`, // è¿™é‡Œæ”¹æˆä½ çš„WSåœ°å€ [[1]](https://poe.com/citation?message_id=330921017671&citation=1)
    success: () => console.log('WebSocket connected')
  })

  ws.value.onOpen(() => {
    console.log('è¿æ¥æˆåŠŸ')
  })

  ws.value.onMessage((res: any) => {
    try {
      const data = JSON.parse(res.data)
      currentTaskId.value = data.task_id

      // å¤„ç†åœæ­¢
      if(data.stopped) {
        isGenerating.value = false
        return
      }

      // å¤„ç†é”™è¯¯
      if(data.error) {
        uni.showToast({ title: data.error, icon: 'none' })
        isGenerating.value = false
        return
      }

      // å¤„ç†ç»“æŸ
      if(data.end) {
        isGenerating.value = false
        return
      }

      // å¤„ç†å›ç­”
      if(data.answer) {
        isGenerating.value = true
        const lastMsg = messageList.value[messageList.value.length - 1]

        if(!lastMsg || lastMsg.type === 'user') {
          messageList.value.push({
            type: 'ai',
            content: data.answer
          })
        } else {
          lastMsg.content += data.answer
        }
        scrollToBottom()
      }
    } catch (error) {
      console.error('Parse message error:', error)
    }
  })
}

// å‘é€æ¶ˆæ¯
function sendMessage() {
  if(!inputText.value) return

  messageList.value.push({
    type: 'user',
    content: inputText.value
  })

  ws.value?.send({
    data: JSON.stringify({
      query: inputText.value,
      user_id: 1  // æ›¿æ¢æˆå®é™…ç”¨æˆ·ID
    })
  })

  inputText.value = ''
  scrollToBottom()
}

// åœæ­¢ç”Ÿæˆ
function stopGenerate() {
  if(isGenerating.value && currentTaskId.value) {
    uni.request({
      url: `${import.meta.env.VITE_BASE_URL}chat/stop`,
      method: 'POST',
      data: {
        task_id: currentTaskId.value
      }
    })
  }
}

// æ»šåŠ¨åˆ°åº•éƒ¨
function scrollToBottom() {
  nextTick(() => {
    const query = uni.createSelectorQuery()
    query.select('.message-inner').boundingClientRect((data: any) => {
      if(data) {
        scrollTop.value = data.height
      }
    }).exec()
  })
}

// åˆå§‹åŒ–è¿æ¥
onMounted(() => {
  connectWebSocket()
})

// ç»„ä»¶é”€æ¯æ—¶å…³é—­è¿æ¥
onUnmounted(() => {
  if(ws.value) {
    ws.value.close()
    ws.value = null
  }
})
</script>

<style lang="scss" scoped>
</style>
```

### sse

```html
// page.vue
<template>
  <view class="container">
    <!-- æ˜¾ç¤ºæ¥æ”¶åˆ°çš„æ¶ˆæ¯ -->
    <view class="message" v-if="message">
      {{ message }}
    </view>
  </view>
</template>

<script lang="ts" setup>
import { ref, onUnmounted } from 'vue'
import { Base64 } from './base64'

const message = ref('')
let requestTask: any = null

// åˆå§‹åŒ–SSEè¿æ¥
const initSSE = () => {
  const token = uni.getStorageSync('token')

  // #ifdef MP-WEIXIN
  //@ts-ignore
  requestTask = wx.request({
    url: `${import.meta.env.VITE_BASE_URL}/your-sse-endpoint`,
    header: {
      "Authorization": `Bearer ${token}`
    },
    enableChunked: true, // å¯ç”¨åˆ†å—ä¼ è¾“
    success: (res: any) => {
      console.log('SSEè¿æ¥æˆåŠŸ')
    },
    fail: (err: any) => {
      console.error('SSEè¿æ¥å¤±è´¥:', err)
    }
  })

  // ç›‘å¬åˆ†å—æ•°æ®
  requestTask.onChunkReceived((res: any) => {
    try {
      //@ts-ignore
      const base64Str = wx.arrayBufferToBase64(res.data)
      const text = new Base64().decode(base64Str)

      if (text) {
        // è§£æSSEæ¶ˆæ¯
        const lines = text.split('\n')
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6))
            // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
            message.value = data
          }
        }
      }
    } catch (e: any) {
      uni.showModal({
        title: "é”™è¯¯",
        content: e.message,
        showCancel: false
      });
    }
  })
  // #endif
}

onLoaded(() => {
  initSSE()
})

// é¡µé¢å¸è½½æ—¶æ¸…ç†
onUnmounted(() => {
  if (requestTask) {
    requestTask.offChunkReceived()
    requestTask = null
  }
})
</script>

<style lang="scss" scoped>
</style>
```

**å¦å¤–è¿˜æœ‰å¾ˆå¤šå‘å‚è€ƒ[è¿™é‡Œ](../FrontEnd/Miniapp/Uniapp/è¸©è¿‡çš„å‘.mdx)**
