这是一份整理好的 DSPy 模块功能对比表，方便您快速查阅各模块的作用、适用场景及主要区别。

| 模块名称 (Module) | 类型/分类 | 核心作用 | 适用场景 | 核心区别/备注 |
| :--- | :--- | :--- | :--- | :--- |
| **Module** | **基础基类** | 所有 DSPy 程序的父类 (类似于 PyTorch 的 `nn.Module`)。 | 自定义流程或组合多个模块时使用。 | 用于管理子模块和参数，不可直接运行，需继承使用。 |
| **Predict** | **基础执行** | 最原子的“输入 -> 输出”映射，直接调用 LLM 获取答案。 | 简单任务、分类任务，或完全依赖指令微调的场景。 | **不包含**推理步骤，直接生成结果。 |
| **ChainOfThought** | **推理增强** | 也就是 **CoT**。在生成答案前，先生成“推理理由 (Rationale)”。 | 逻辑推理、常识问答、复杂文本分析。 | 比 `Predict` 多了一步“思考”，能显著提升复杂问题的准确率。 |
| **ProgramOfThought** | **推理增强** | 也就是 **PoT**。让 LLM 生成代码来计算答案，并执行代码。 | 数学应用题、日期计算、精确数值处理。 | **用代码逻辑代替语言逻辑**，解决 LLM 算术差、易产生幻觉的问题。 |
| **MultiChainComparison** | **推理增强** | 生成多条不同的推理路径，让模型对比并择优。 | 需要极高准确性、模型容易陷入思维误区的场景。 | **自我对比纠错**，通过“多角度思考”来消除偏差。 |
| **ReAct** | **代理/行动** | 经典的“思考-行动-观察”循环范式。 | 需要使用外部工具（如搜索、查库、计算器）的智能体。 | 能够**调用预定义工具**与外部环境交互。 |
| **CodeAct** | **代理/行动** | 以“编写并执行代码”作为唯一的行动手段。 | 复杂的编程任务，或需要灵活操作环境的智能体。 | 相较于 `ReAct` 调用死板的工具，CodeAct **直接写代码**解决问题，更通用但更难控。 |
| **BestOfN** | **优化/集成** | 生成 N 个候选项，通过评分函数选出得分最高的一个。 | 答案开放性强、有评估指标可用的任务。 | **暴力采样 + 择优**，关注结果的优选。 |
| **Refine** | **优化/集成** | 生成初始答案，然后让模型进行“自我批评”并迭代修改。 | 代码生成、文案写作、长文本摘要。 | **迭代打磨**，关注质量的逐步提升。 |
| **Parallel** | **工具/辅助** | 并发执行多个模块或请求。 | 大规模数据处理、批量评估。 | 用于加速执行效率，不改变推理逻辑。 |

### 总结建议：
*   **新手入门**：主要使用 `Predict` 和 `ChainOfThought`。
*   **涉及计算/数学**：首选 `ProgramOfThought`。
*   **需要联网/查资料**：使用 `ReAct`。
*   **追求极致效果**：在上述基础上套用 `BestOfN` 或 `MultiChainComparison`。