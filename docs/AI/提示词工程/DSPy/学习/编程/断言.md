!!! warning "断言已被弃用且不再支持。请改用 `dspy.Refine` 模块（或 `dspy.Suggest`）。"

以下内容已被弃用，并计划移除。

## 简介

语言模型 (LM) 改变了我们与机器学习交互的方式，提供了强大的自然语言理解和生成能力。然而，确保这些模型遵守特定领域的约束仍然是一个挑战。尽管微调或“提示工程”等技术有所发展，但这些方法极其繁琐，并且依赖于大量的手工调整来引导 LM 遵守特定约束。即使是 DSPy 的编程提示管道模块化，也缺乏有效自动执行这些约束的机制。

为了解决这个问题，我们引入了 DSPy Assertions（断言），这是 DSPy 框架内的一个功能，旨在自动执行对 LM 的计算约束。DSPy Assertions 使开发人员能够以最少的手动干预引导 LM 达到预期的结果，从而提高 LM 输出的可靠性、可预测性和正确性。

### dspy.Assert 和 dspy.Suggest API

我们在 DSPy Assertions 中引入了两个主要构造：

- **`dspy.Assert`**:
  - **参数**:
    - `constraint (bool)`: Python 定义的布尔验证检查的结果。
    - `msg (Optional[str])`: 用户定义的错误消息，提供反馈或更正指导。
    - `backtrack (Optional[module])`: 指定约束失败时重试的目标模块。默认的回溯模块是断言之前的最后一个模块。
  - **行为**: 在失败时启动重试，动态调整管道的执行。如果失败持续存在，它将停止执行并引发 `dspy.AssertionError`。

- **`dspy.Suggest`**:
  - **参数**: 与 `dspy.Assert` 类似。
  - **行为**: 通过重试鼓励自我修正，而不强制停止。在达到最大回溯尝试次数后记录失败并继续执行。

- **dspy.Assert 与 Python 断言的区别**: 与传统的 Python `assert` 语句在失败时终止程序不同，`dspy.Assert` 执行复杂的重试机制，允许管道进行调整。

具体来说，当不满足约束时：

- 回溯机制：启动底层的回溯，为模型提供自我修正并继续的机会，这是通过签名修改完成的。
- 动态签名修改：通过添加以下字段在内部修改 DSPy 程序的签名：
    - Past Output（过去的输出）：未通过 validation_fn 的模型过去输出
    - Instruction（指令）：用户定义的关于出了什么问题以及可能修复什么的反馈消息

如果错误持续超过 `max_backtracking_attempts`，则 `dspy.Assert` 将停止管道执行，并通过 `dspy.AssertionError` 提醒您。这确保您的程序不会在具有“糟糕”LM 行为的情况下继续执行，并立即突出显示样本失败输出以供用户评估。

- **dspy.Suggest 与 dspy.Assert**: 另一方面，`dspy.Suggest` 提供了一种更温和的方法。它保持与 `dspy.Assert` 相同的重试回溯，但作为一个温和的助推器。如果模型输出在 `max_backtracking_attempts` 后仍无法通过模型约束，`dspy.Suggest` 将记录持续的失败并继续对剩余数据执行程序。这确保了 LM 管道以“尽力而为”的方式工作，而不会停止执行。

- **`dspy.Suggest`** 语句最好在评估阶段用作“助手”，在不停止管道的情况下提供指导和潜在的更正。
- **`dspy.Assert`** 语句建议在开发阶段用作“检查器”，以确保 LM 按预期行事，为在开发周期的早期识别和解决错误提供了强大的机制。

## 用例：在 DSPy 程序中包含断言

我们从使用介绍演练中定义的简化的多跳 QA SimplifiedBaleen 管道示例开始。

```python
class SimplifiedBaleen(dspy.Module):
    def __init__(self, passages_per_hop=2, max_hops=2):
        super().__init__()

        self.generate_query = [dspy.ChainOfThought(GenerateSearchQuery) for _ in range(max_hops)]
        self.retrieve = dspy.Retrieve(k=passages_per_hop)
        self.generate_answer = dspy.ChainOfThought(GenerateAnswer)
        self.max_hops = max_hops

    def forward(self, question):
        context = []
        prev_queries = [question]

        for hop in range(self.max_hops):
            query = self.generate_query[hop](context=context, question=question).query
            prev_queries.append(query)
            passages = self.retrieve(query).passages
            context = deduplicate(context + passages)
        
        pred = self.generate_answer(context=context, question=question)
        pred = dspy.Prediction(context=context, answer=pred.answer)
        return pred

baleen = SimplifiedBaleen()

baleen(question = "Which award did Gary Zukav's first book receive?")
```

要包含 DSPy Assertions，我们只需定义验证函数并在相应的模型生成后声明断言。

对于此用例，假设我们要施加以下约束：
    1. 长度 - 每个查询应少于 100 个字符
    2. 唯一性 - 每个生成的查询应与之前生成的查询不同。

我们可以将这些验证检查定义为布尔函数：

```python
#simplistic boolean check for query length
len(query) <= 100

#Python function for validating distinct queries
def validate_query_distinction_local(previous_queries, query):
    """check if query is distinct from previous queries"""
    if previous_queries == []:
        return True
    if dspy.evaluate.answer_exact_match_str(query, previous_queries, frac=0.8):
        return False
    return True
```

我们可以通过 `dspy.Suggest` 语句声明这些验证检查（因为我们要以尽力而为的演示来测试程序）。我们希望将这些保留在查询生成 `query = self.generate_query[hop](context=context, question=question).query` 之后。

```python
dspy.Suggest(
    len(query) <= 100,
    "Query should be short and less than 100 characters",
    target_module=self.generate_query
)

dspy.Suggest(
    validate_query_distinction_local(prev_queries, query),
    "Query should be distinct from: "
    + "; ".join(f"{i+1}) {q}" for i, q in enumerate(prev_queries)),
    target_module=self.generate_query
)
```

如果您正在进行断言效果的比较评估，建议将带有断言的程序与原始程序分开定义。如果不是，请随意设置 Assertions！

让我们看看包含 Assertions 的 SimplifiedBaleen 程序是什么样子的：

```python
class SimplifiedBaleenAssertions(dspy.Module):
    def __init__(self, passages_per_hop=2, max_hops=2):
        super().__init__()
        self.generate_query = [dspy.ChainOfThought(GenerateSearchQuery) for _ in range(max_hops)]
        self.retrieve = dspy.Retrieve(k=passages_per_hop)
        self.generate_answer = dspy.ChainOfThought(GenerateAnswer)
        self.max_hops = max_hops

    def forward(self, question):
        context = []
        prev_queries = [question]

        for hop in range(self.max_hops):
            query = self.generate_query[hop](context=context, question=question).query

            dspy.Suggest(
                len(query) <= 100,
                "Query should be short and less than 100 characters",
                target_module=self.generate_query
            )

            dspy.Suggest(
                validate_query_distinction_local(prev_queries, query),
                "Query should be distinct from: "
                + "; ".join(f"{i+1}) {q}" for i, q in enumerate(prev_queries)),
                target_module=self.generate_query
            )

            prev_queries.append(query)
            passages = self.retrieve(query).passages
            context = deduplicate(context + passages)
        
        if all_queries_distinct(prev_queries):
            self.passed_suggestions += 1

        pred = self.generate_answer(context=context, question=question)
        pred = dspy.Prediction(context=context, answer=pred.answer)
        return pred
```

现在调用带有 DSPy Assertions 的程序需要最后一步，即转换程序以将其包装在内部断言回溯和重试逻辑中。

```python
from dspy.primitives.assertions import assert_transform_module, backtrack_handler

baleen_with_assertions = assert_transform_module(SimplifiedBaleenAssertions(), backtrack_handler)

# backtrack_handler is parameterized over a few settings for the backtracking mechanism
# To change the number of max retry attempts, you can do
baleen_with_assertions_retry_once = assert_transform_module(SimplifiedBaleenAssertions(), 
    functools.partial(backtrack_handler, max_backtracks=1))
```

或者，您也可以直接在带有 `dspy.Assert/Suggest` 语句的程序上调用 `activate_assertions`，使用默认的回溯机制（`max_backtracks=2`）：

```python
baleen_with_assertions = SimplifiedBaleenAssertions().activate_assertions()
```

现在，让我们通过检查 LM 查询生成的历史记录来看看内部 LM 回溯。在这里我们看到，当查询未能通过少于 100 个字符的验证检查时，其内部 `GenerateSearchQuery` 签名在回溯+重试过程中会被动态修改，以包含过去的查询和相应的用户定义指令：`"Query should be short and less than 100 characters"`。


```text
Write a simple search query that will help answer a complex question.

---

Follow the following format.

Context: may contain relevant facts

Question: ${question}

Reasoning: Let's think step by step in order to ${produce the query}. We ...

Query: ${query}

---

Context:
[1] «Kerry Condon | Kerry Condon (born 4 January 1983) is [...]»
[2] «Corona Riccardo | Corona Riccardo (c. 1878October 15, 1917) was [...]»

Question: Who acted in the shot film The Shore and is also the youngest actress ever to play Ophelia in a Royal Shakespeare Company production of "Hamlet." ?

Reasoning: Let's think step by step in order to find the answer to this question. First, we need to identify the actress who played Ophelia in a Royal Shakespeare Company production of "Hamlet." Then, we need to find out if this actress also acted in the short film "The Shore."

Query: "actress who played Ophelia in Royal Shakespeare Company production of Hamlet" + "actress in short film The Shore"



Write a simple search query that will help answer a complex question.

---

Follow the following format.

Context: may contain relevant facts

Question: ${question}

Past Query: past output with errors

Instructions: Some instructions you must satisfy

Query: ${query}

---

Context:
[1] «Kerry Condon | Kerry Condon (born 4 January 1983) is an Irish television and film actress, best known for her role as Octavia of the Julii in the HBO/BBC series "Rome," as Stacey Ehrmantraut in AMC's "Better Call Saul" and as the voice of F.R.I.D.A.Y. in various films in the Marvel Cinematic Universe. She is also the youngest actress ever to play Ophelia in a Royal Shakespeare Company production of "Hamlet."»
[2] «Corona Riccardo | Corona Riccardo (c. 1878October 15, 1917) was an Italian born American actress who had a brief Broadway stage career before leaving to become a wife and mother. Born in Naples she came to acting in 1894 playing a Mexican girl in a play at the Empire Theatre. Wilson Barrett engaged her for a role in his play "The Sign of the Cross" which he took on tour of the United States. Riccardo played the role of Ancaria and later played Berenice in the same play. Robert B. Mantell in 1898 who struck by her beauty also cast her in two Shakespeare plays, "Romeo and Juliet" and "Othello". Author Lewis Strang writing in 1899 said Riccardo was the most promising actress in America at the time. Towards the end of 1898 Mantell chose her for another Shakespeare part, Ophelia im Hamlet. Afterwards she was due to join Augustin Daly's Theatre Company but Daly died in 1899. In 1899 she gained her biggest fame by playing Iras in the first stage production of Ben-Hur.»

Question: Who acted in the shot film The Shore and is also the youngest actress ever to play Ophelia in a Royal Shakespeare Company production of "Hamlet." ?

Past Query: "actress who played Ophelia in Royal Shakespeare Company production of Hamlet" + "actress in short film The Shore"

Instructions: Query should be short and less than 100 characters

Query: "actress Ophelia RSC Hamlet" + "actress The Shore"

```


## 断言驱动的优化

DSPy Assertions 与 DSPy 提供的优化一起工作，特别是 `BootstrapFewShotWithRandomSearch`，包括以下设置：

- 带断言的编译 (Compilation with Assertions)
    这包括编译期间的断言驱动示例引导和反例引导。用于引导少样本演示的教师模型可以利用 DSPy Assertions 来提供强大的引导示例，供学生模型在推理期间学习。在这种设置下，学生模型在推理期间不执行断言感知优化（回溯和重试）。
- 带断言的编译 + 推理 (Compilation + Inference with Assertions)
    -这包括编译和推理中的断言驱动优化。现在教师模型提供断言驱动的示例，但学生可以在推理时利用自己的断言进一步优化。
```python
teleprompter = BootstrapFewShotWithRandomSearch(
    metric=validate_context_and_answer_and_hops,
    max_bootstrapped_demos=max_bootstrapped_demos,
    num_candidate_programs=6,
)

#Compilation with Assertions
compiled_with_assertions_baleen = teleprompter.compile(student = baleen, teacher = baleen_with_assertions, trainset = trainset, valset = devset)

#Compilation + Inference with Assertions
compiled_baleen_with_assertions = teleprompter.compile(student=baleen_with_assertions, teacher = baleen_with_assertions, trainset=trainset, valset=devset)

```