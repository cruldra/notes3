---
sidebar_position: 2
---

DSPy 为 **使用工具的智能体 (tool-using agents)** 提供了强大的支持，这些智能体可以与外部函数、API 和服务进行交互。工具使语言模型能够通过执行操作、检索信息和动态处理数据来超越文本生成。

在 DSPy 中使用工具有两种主要方法：

1. **`dspy.ReAct`** - 全托管的工具智能体，自动处理推理和工具调用
2. **手动工具处理** - 使用 `dspy.Tool`、`dspy.ToolCalls` 和自定义签名直接控制工具调用

## 方法 1: 使用 `dspy.ReAct` (全托管)

`dspy.ReAct` 模块实现了推理和行动 (Reasoning and Acting, ReAct) 模式，其中语言模型迭代地推理当前情况并决定调用哪些工具。

### 基本示例

```python
import dspy

# 将你的工具定义为函数
def get_weather(city: str) -> str:
    """Get the current weather for a city."""
    # 在实际实现中，这将调用天气 API
    return f"The weather in {city} is sunny and 75°F"

def search_web(query: str) -> str:
    """Search the web for information."""
    # 在实际实现中，这将调用搜索 API
    return f"Search results for '{query}': [relevant information...]"

# 创建 ReAct 智能体
react_agent = dspy.ReAct(
    signature="question -> answer",
    tools=[get_weather, search_web],
    max_iters=5
)

# 使用智能体
result = react_agent(question="What's the weather like in Tokyo?")
print(result.answer)
print("Tool calls made:", result.trajectory)
```

我看到上面的代码时的第一反应是[有点疑惑](../../参考/1.md)

### ReAct 特性

- **自动推理**：模型逐步思考问题
- **工具选择**：根据情况自动选择要使用的工具
- **迭代执行**：可以进行多次工具调用以收集信息
- **错误处理**：针对失败的工具调用内置错误恢复
- **轨迹跟踪**：推理和工具调用的完整历史记录

### ReAct 参数

```python
react_agent = dspy.ReAct(
    signature="question -> answer",  # 输入/输出规范
    tools=[tool1, tool2, tool3],     # 可用工具列表
    max_iters=10                     # 最大工具调用迭代次数
)
```

## 方法 2: 手动工具处理

为了更好地控制工具调用过程，你可以使用 DSPy 的工具类型手动处理工具。

!!! note "版本要求"
    以下示例中使用的 `ToolCall.execute()` 方法从 **dspy 3.0.4b2** 起可用。如果你使用的是 3.0.3 或更早版本，则需要升级才能使用此功能。

### 基本设置

```python
import dspy

class ToolSignature(dspy.Signature):
    """Signature for manual tool handling."""
    question: str = dspy.InputField()
    tools: list[dspy.Tool] = dspy.InputField()
    outputs: dspy.ToolCalls = dspy.OutputField()

def weather(city: str) -> str:
    """Get weather information for a city."""
    return f"The weather in {city} is sunny"

def calculator(expression: str) -> str:
    """Evaluate a mathematical expression."""
    try:
        result = eval(expression)  # 注意：在生产中安全使用
        return f"The result is {result}"
    except:
        return "Invalid expression"

# 创建工具实例
tools = {
    "weather": dspy.Tool(weather),
    "calculator": dspy.Tool(calculator)
}

# 创建预测器
predictor = dspy.Predict(ToolSignature)

# 进行预测
response = predictor(
    question="What's the weather in New York?",
    tools=list(tools.values())
)

# 执行工具调用
for call in response.outputs.tool_calls:
    # 执行工具调用
    result = call.execute()
    # 对于 3.0.4b2 之前的版本，使用: result = tools[call.name](**call.args)
    print(f"Tool: {call.name}")
    print(f"Args: {call.args}")
    print(f"Result: {result}")
```

### 理解 `dspy.Tool`

`dspy.Tool` 类包装常规 Python 函数，使其与 DSPy 的工具系统兼容：

```python
def my_function(param1: str, param2: int = 5) -> str:
    """A sample function with parameters."""
    return f"Processed {param1} with value {param2}"

# 创建工具
tool = dspy.Tool(my_function)

# 工具属性
print(tool.name)        # "my_function"
print(tool.desc)        # 函数的文档字符串
print(tool.args)        # 参数模式
print(str(tool))        # 完整工具描述
```

### 理解 `dspy.ToolCalls`

!!! note "版本要求"
    `ToolCall.execute()` 方法从 **dspy 3.0.4b2** 起可用。如果你使用的是早期版本，则需要升级才能使用此功能。

`dspy.ToolCalls` 类型表示可以进行工具调用的模型的输出。每个单独的工具调用都可以使用 `execute` 方法执行：

```python
# 获取带有工具调用的响应后
for call in response.outputs.tool_calls:
    print(f"Tool name: {call.name}")
    print(f"Arguments: {call.args}")
    
    # 使用不同选项执行单独的工具调用：
    
    # 选项 1: 自动发现 (在 locals/globals 中查找函数)
    result = call.execute()  # 按名称自动查找函数

    # 选项 2: 作为字典传递工具 (最明确)
    result = call.execute(functions={"weather": weather, "calculator": calculator})
    
    # 选项 3: 传递 Tool 对象列表
    result = call.execute(functions=[dspy.Tool(weather), dspy.Tool(calculator)])
    
    # 选项 4: 对于 3.0.4b2 之前的版本 (手动工具查找)
    # tools_dict = {"weather": weather, "calculator": calculator}
    # result = tools_dict[call.name](**call.args)
    
    print(f"Result: {result}")
```

## 使用原生工具调用

DSPy 适配器支持 **原生函数调用 (native function calling)**，它利用底层语言模型内置的工具调用功能，而不是依赖基于文本的解析。这种方法可以提供更可靠的工具执行，并更好地与支持原生函数调用的模型集成。

!!! warning "原生工具调用不保证更好的质量"

    原生工具调用产生的质量可能会低于自定义工具调用。

### 适配器行为

不同的 DSPy 适配器对原生函数调用有不同的默认值：

- **`ChatAdapter`** - 默认使用 `use_native_function_calling=False`（依赖文本解析）
- **`JSONAdapter`** - 默认使用 `use_native_function_calling=True`（使用原生函数调用）

你可以通过在创建适配器时显式设置 `use_native_function_calling` 参数来覆盖这些默认值。

### 配置

```python
import dspy

# 启用了原生函数调用的 ChatAdapter
chat_adapter_native = dspy.ChatAdapter(use_native_function_calling=True)

# 禁用了原生函数调用的 JSONAdapter
json_adapter_manual = dspy.JSONAdapter(use_native_function_calling=False)

# 配置 DSPy 使用适配器
dspy.configure(lm=dspy.LM(model="openai/gpt-4o"), adapter=chat_adapter_native)
```

你可以启用 [MLflow 跟踪](https://dspy.ai/tutorials/observability/) 来检查原生工具调用的使用情况。如果你使用启用了原生函数调用的 `JSONAdapter` 或 `ChatAdapter` 运行上一节中提供的代码片段，你应该会看到原生函数调用参数 `tools` 设置如下图所示：

![native tool calling]


### 模型兼容性

原生函数调用使用 `litellm.supports_function_calling()` 自动检测模型支持。如果模型不支持原生函数调用，即使设置了 `use_native_function_calling=True`，DSPy 也会回退到基于文本的手动解析。

## 异步工具

DSPy 工具支持同步和异步函数。在使用异步工具时，你有两个选择：

### 对异步工具使用 `acall`

在使用异步工具时，推荐的方法是使用 `acall`：

```python
import asyncio
import dspy

async def async_weather(city: str) -> str:
    """Get weather information asynchronously."""
    await asyncio.sleep(0.1)  # Simulate async API call
    return f"The weather in {city} is sunny"

tool = dspy.Tool(async_weather)

# 对异步工具使用 acall
result = await tool.acall(city="New York")
print(result)
```

### 在同步模式下运行异步工具

如果你需要从同步代码调用异步工具，你可以使用 `allow_tool_async_sync_conversion` 设置启用自动转换：

```python
import asyncio
import dspy

async def async_weather(city: str) -> str:
    """Get weather information asynchronously."""
    await asyncio.sleep(0.1)
    return f"The weather in {city} is sunny"

tool = dspy.Tool(async_weather)

# 启用异步到同步转换
with dspy.context(allow_tool_async_sync_conversion=True):
    # 现在你可以在异步工具上使用 __call__
    result = tool(city="New York")
    print(result)
```

## 最佳实践

### 1. 工具函数设计

- **清晰的文档字符串**：带有描述性文档的工具效果更好
- **类型提示**：提供清晰的参数和返回类型
- **简单参数**：使用基本类型 (str, int, bool, dict, list) 或 Pydantic 模型

```python
def good_tool(city: str, units: str = "celsius") -> str:
    """
    Get weather information for a specific city.
    
    Args:
        city: The name of the city to get weather for
        units: Temperature units, either 'celsius' or 'fahrenheit'
    
    Returns:
        A string describing the current weather conditions
    """
    # 带有适当错误处理的实现
    if not city.strip():
        return "Error: City name cannot be empty"
    
    # Weather logic here...
    return f"Weather in {city}: 25°{units[0].upper()}, sunny"
```

### 2. 在 ReAct 和手动处理之间选择

**在以下情况下使用 `dspy.ReAct`：**

- 你想要自动推理和工具选择
- 任务需要多次工具调用
- 你需要内置的错误恢复
- 你想专注于工具实现而不是编排

**在以下情况下使用手动工具处理：**

- 你需要对工具执行进行精确控制
- 你想要自定义错误处理逻辑
- 你想最小化延迟
- 你的工具不返回任何内容（void 函数）

DSPy 中的工具提供了一种强大的方式，将语言模型的功能扩展到文本生成之外。无论是使用全自动的 ReAct 方法还是手动工具处理，你都可以构建通过代码与世界交互的复杂智能体。