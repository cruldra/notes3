## 什么是适配器？

适配器是 `dspy.Predict` 和实际语言模型 (LM) 之间的桥梁。当你调用一个 DSPy 模块时，适配器获取你的签名、用户输入和其他属性（如 `demos`，即少样本示例），并将它们转换为发送给 LM 的多轮消息。

适配器系统负责：

- 将 DSPy 签名转换为定义任务和请求/响应结构的系统消息。
- 根据 DSPy 签名中概述的请求结构格式化输入数据。
- 将 LM 响应解析回结构化的 DSPy 输出，例如 `dspy.Prediction` 实例。
- 管理对话历史和函数调用。
- 将预构建的 DSPy 类型转换为 LM 提示消息，例如 `dspy.Tool`、`dspy.Image` 等。

## 配置适配器

你可以使用 `dspy.configure(adapter=...)` 为整个 Python 进程选择适配器，或者使用 `with dspy.context(adapter=...):` 仅影响特定的命名空间。

如果在 DSPy 工作流中未指定适配器，每个 `dspy.Predict.__call__` 默认使用 `dspy.ChatAdapter`。因此，下面的两个代码片段是等效的：

```python
import dspy

dspy.configure(lm=dspy.LM("openai/gpt-4o-mini"))

predict = dspy.Predict("question -> answer")
result = predict(question="What is the capital of France?")
```

```python
import dspy

dspy.configure(
    lm=dspy.LM("openai/gpt-4o-mini"),
    adapter=dspy.ChatAdapter(),  # 这是默认值
)

predict = dspy.Predict("question -> answer")
result = predict(question="What is the capital of France?")
```

## 适配器在系统中的位置

流程如下：

1. 用户调用他们的 DSPy 智能体，通常是一个带有输入的 `dspy.Module`。
2. 调用内部的 `dspy.Predict` 以获取 LM 响应。
3. `dspy.Predict` 调用 **Adapter.format()**，将其签名、输入和演示转换为发送给 `dspy.LM` 的多轮消息。`dspy.LM` 是 `litellm` 的一个瘦包装器，用于与 LM 端点通信。
4. LM 接收消息并生成响应。
5. **Adapter.parse()** 将 LM 响应转换为结构化的 DSPy 输出，如签名中所指定。
6. `dspy.Predict` 的调用者接收解析后的输出。

你可以显式调用 `Adapter.format()` 来查看发送给 LM 的消息。

```python
# Simplified flow example
signature = dspy.Signature("question -> answer")
inputs = {"question": "What is 2+2?"}
demos = [{"question": "What is 1+1?", "answer": "2"}]

adapter = dspy.ChatAdapter()
print(adapter.format(signature, demos, inputs))
```

输出应类似于：

```
{'role': 'system', 'content': 'Your input fields are:\n1. `question` (str):\nYour output fields are:\n1. `answer` (str):\nAll interactions will be structured in the following way, with the appropriate values filled in.\n\n[[ ## question ## ]]\n{question}\n\n[[ ## answer ## ]]\n{answer}\n\n[[ ## completed ## ]]\nIn adhering to this structure, your objective is: 
        Given the fields `question`, produce the fields `answer`.`}
{'role': 'user', 'content': '[[ ## question ## ]]\nWhat is 1+1?'}
{'role': 'assistant', 'content': '[[ ## answer ## ]]\n2\n\n[[ ## completed ## ]]\n'}
{'role': 'user', 'content': '[[ ## question ## ]]\nWhat is 2+2?\n\nRespond with the corresponding output fields, starting with the field `[[ ## answer ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.'}
```

你也可以通过调用 `adapter.format_system_message(signature)` 仅获取系统消息。

```python
import dspy

signature = dspy.Signature("question -> answer")
system_message = dspy.ChatAdapter().format_system_message(signature)
print(system_message)
```

输出应类似于：

```
Your input fields are:
1. `question` (str):
Your output fields are:
1. `answer` (str):
All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## question ## ]]
{question}
[[ ## answer ## ]]
{answer}
[[ ## completed ## ]]
In adhering to this structure, your objective is: 
        Given the fields `question`, produce the fields `answer`.
```

## 适配器类型

DSPy 提供了几种适配器类型，每种都针对特定的用例量身定制：

### ChatAdapter

**ChatAdapter** 是默认适配器，适用于所有语言模型。它使用基于字段的格式，带有特殊标记。

#### 格式结构

ChatAdapter 使用 `[[ ## field_name ## ]]` 标记来划分字段。对于非原始 Python 类型的字段，它包含类型的 JSON 模式。下面，我们使用 `dspy.inspect_history()` 清楚地显示 `dspy.ChatAdapter` 格式化的消息。

```python
import dspy
import pydantic

dspy.configure(lm=dspy.LM("openai/gpt-4o-mini"), adapter=dspy.ChatAdapter())


class ScienceNews(pydantic.BaseModel):
    text: str
    scientists_involved: list[str]


class NewsQA(dspy.Signature):
    """Get news about the given science field"""

    science_field: str = dspy.InputField()
    year: int = dspy.InputField()
    num_of_outputs: int = dspy.InputField()
    news: list[ScienceNews] = dspy.OutputField(desc="science news")


predict = dspy.Predict(NewsQA)
predict(science_field="Computer Theory", year=2022, num_of_outputs=1)
dspy.inspect_history()
```

输出如下所示：

```
[2025-08-15T22:24:29.378666]

System message:

Your input fields are:
1. `science_field` (str):
2. `year` (int):
3. `num_of_outputs` (int):
Your output fields are:
1. `news` (list[ScienceNews]): science news
All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## science_field ## ]]
{science_field}

[[ ## year ## ]]
{year}

[[ ## num_of_outputs ## ]]
{num_of_outputs}

[[ ## news ## ]]
{news}        # note: the value you produce must adhere to the JSON schema: {"type": "array", "$defs": {"ScienceNews": {"type": "object", "properties": {"scientists_involved": {"type": "array", "items": {"type": "string"}, "title": "Scientists Involved"}, "text": {"type": "string", "title": "Text"}}, "required": ["text", "scientists_involved"], "title": "ScienceNews"}}, "items": {"$ref": "#/$defs/ScienceNews"}}

[[ ## completed ## ]]
In adhering to this structure, your objective is:
        Get news about the given science field


User message:

[[ ## science_field ## ]]
Computer Theory

[[ ## year ## ]]
2022

[[ ## num_of_outputs ## ]]
1

Respond with the corresponding output fields, starting with the field `[[ ## news ## ]]` (must be formatted as a valid Python list[ScienceNews]), and then ending with the marker for `[[ ## completed ## ]]`.


Response:

[[ ## news ## ]]
[
    {
        "scientists_involved": ["John Doe", "Jane Smith"],
        "text": "In 2022, researchers made significant advancements in quantum computing algorithms, demonstrating their potential to solve complex problems faster than classical computers. This breakthrough could revolutionize fields such as cryptography and optimization."
    }
]

[[ ## completed ## ]]
```

!!! info "练习：在打印的 LM 历史记录中定位签名信息"

    尝试调整签名，并观察更改如何反映在打印的 LM 消息中。


每个字段前面都有一个标记 `[[ ## field_name ## ]]`。如果输出字段具有非原始类型，说明中将包含类型的 JSON 模式，并且输出将相应地格式化。由于输出字段是按照 ChatAdapter 定义的结构组织的，因此可以自动将其解析为结构化数据。

#### 何时使用 ChatAdapter

`ChatAdapter` 提供以下优势：

- **通用兼容性**：适用于所有语言模型，尽管较小的模型生成的响应可能不符合要求的格式。
- **回退保护**：如果 `ChatAdapter` 失败，它会自动重试 `JSONAdapter`。

总的来说，如果你没有特殊要求，`ChatAdapter` 是一个可靠的选择。

#### 何时不使用 ChatAdapter

如果你属于以下情况，请避免使用 `ChatAdapter`：

- **延迟敏感**：与其他适配器相比，`ChatAdapter` 包含更多的样板输出标记，因此如果你正在构建对延迟敏感的系统，请考虑使用其他适配器。

### JSONAdapter

**JSONAdapter** 提示 LM 返回包含签名中指定的所有输出字段的 JSON 数据。对于支持通过 `response_format` 参数进行结构化输出的模型，它非常有效，利用本机 JSON 生成功能实现更可靠的解析。

#### 格式结构

`JSONAdapter` 格式化的提示的输入部分类似于 `ChatAdapter`，但输出部分有所不同，如下所示：

```python
import dspy
import pydantic

dspy.configure(lm=dspy.LM("openai/gpt-4o-mini"), adapter=dspy.JSONAdapter())


class ScienceNews(pydantic.BaseModel):
    text: str
    scientists_involved: list[str]


class NewsQA(dspy.Signature):
    """Get news about the given science field"""

    science_field: str = dspy.InputField()
    year: int = dspy.InputField()
    num_of_outputs: int = dspy.InputField()
    news: list[ScienceNews] = dspy.OutputField(desc="science news")


predict = dspy.Predict(NewsQA)
predict(science_field="Computer Theory", year=2022, num_of_outputs=1)
dspy.inspect_history()
```

```
System message:

Your input fields are:
1. `science_field` (str):
2. `year` (int):
3. `num_of_outputs` (int):
Your output fields are:
1. `news` (list[ScienceNews]): science news
All interactions will be structured in the following way, with the appropriate values filled in.

Inputs will have the following structure:

[[ ## science_field ## ]]
{science_field}

[[ ## year ## ]]
{year}

[[ ## num_of_outputs ## ]]
{num_of_outputs}

Outputs will be a JSON object with the following fields.

{
  "news": "{news}        # note: the value you produce must adhere to the JSON schema: {\"type\": \"array\", \"$defs\": {\"ScienceNews\": {\"type\": \"object\", \"properties\": {\"scientists_involved\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}, \"title\": \"Scientists Involved\"}, \"text\": {\"type\": \"string\", \"title\": \"Text\"}}, \"required\": [\"text\", \"scientists_involved\"], \"title\": \"ScienceNews\"}}, \"items\": {\"$ref\": \"#/$defs/ScienceNews\"}}"
}
In adhering to this structure, your objective is:
        Get news about the given science field


User message:

[[ ## science_field ## ]]
Computer Theory

[[ ## year ## ]]
2022

[[ ## num_of_outputs ## ]]
1

Respond with a JSON object in the following order of fields: `news` (must be formatted as a valid Python list[ScienceNews]).


Response:

{
  "news": [
    {
      "text": "In 2022, researchers made significant advancements in quantum computing algorithms, demonstrating that quantum systems can outperform classical computers in specific tasks. This breakthrough could revolutionize fields such as cryptography and complex system simulations.",
      "scientists_involved": [
        "Dr. Alice Smith",
        "Dr. Bob Johnson",
        "Dr. Carol Lee"
      ]
    }
  ]
}
```

#### 何时使用 JSONAdapter

`JSONAdapter` 擅长于：

- **结构化输出支持**：当模型支持 `response_format` 参数时。
- **低延迟**：LM 响应中的样板最少，从而产生更快的响应。

#### 何时不使用 JSONAdapter

如果你属于以下情况，请避免使用 `JSONAdapter`：

- 使用不支持原生结构化输出的模型，例如在 Ollama 上托管的小型开源模型。

## 总结

适配器是 DSPy 的重要组成部分，它弥合了结构化 DSPy 签名和语言模型 API 之间的差距。
了解何时以及如何使用不同的适配器将帮助你构建更可靠、更高效的 DSPy 程序。