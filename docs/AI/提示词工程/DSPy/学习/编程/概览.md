---
sidebar_position: 1
---

DSPy 赌的是 *编写代码而不是字符串*。换句话说，构建正确的控制流至关重要。从 **定义你的任务** 开始。你的系统的输入是什么，你的系统应该产生什么作为输出？它是基于你的数据的聊天机器人，还是代码助手？或者也许是一个用于翻译、高亮搜索结果片段或生成带有引用的报告的系统？

接下来，**定义你的初始管道**。你的 DSPy 程序可以只是一个模块吗，还是需要将其分解为几个步骤？你需要检索或其他工具，如计算器或日历 API 吗？解决你的问题是否有典型的多个范围明确的步骤工作流，还是你想为你的任务使用更开放式的工具和智能体？思考这些问题，但从简单的开始，也许只用一个 `dspy.ChainOfThought` 模块，然后根据观察结果逐步增加复杂性。

当你这样做时，**制作并尝试少量的示例**作为你程序的输入。在这个阶段考虑使用强大的 LM，或者几个不同的 LM，只是为了了解什么是可能的。记录你尝试过的有趣的（既有简单的也有困难的）示例。当你稍后进行评估和优化时，这将非常有用。

??? "除了鼓励良好的设计模式之外，DSPy 在这方面还有什么帮助？"

    传统的提示将你的基本系统架构与不可移植到新 LM、目标或管道的偶然选择耦合在一起。传统的提示要求 LM 接收一些输入并产生某些类型的输出（*签名*），以某些方式格式化输入并请求其可以准确解析的形式的输出（*适配器*），要求 LM 应用某些策略，如“逐步思考”或使用工具（*模块* 的逻辑），并依赖大量的试错来发现要求每个 LM 这样做正确方式（一种手动的 *优化* 形式）。
    
    DSPy 分离了这些关注点，并自动化了较低级别的关注点，直到你需要考虑它们。这允许你编写更短的代码，具有更高的可移植性。例如，如果你使用 DSPy 模块编写程序，你可以交换 LM 或其适配器而不更改其余逻辑。或者你可以用另一个模块（如 `dspy.ProgramOfThought`）交换一个模块（如 `dspy.ChainOfThought`），而不修改你的签名。当你准备好使用优化器时，同一个程序可以优化其提示或微调其 LM 权重。


[各个组件的职责](../../参考/3.md)