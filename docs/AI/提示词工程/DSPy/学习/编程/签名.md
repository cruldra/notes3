---
sidebar_position: 2
---

当我们在 DSPy 中为 LM 分配任务时，我们以签名 (Signature) 的形式指定我们需要的行为。

**签名是 DSPy 模块输入/输出行为的声明性规范。** 签名允许你告诉 LM *做什么*，而不是指定我们应该*如何*要求 LM 去做。

你可能熟悉函数签名，它指定了输入和输出参数及其类型。DSPy 签名类似，但有一些区别。典型的函数签名只是 *描述* 事物，而 DSPy 签名 *声明并初始化* 模块的行为。此外，字段名称在 DSPy 签名中很重要。你用简单的英语表达语义角色：`question`（问题）不同于 `answer`（答案），`sql_query`（SQL 查询）不同于 `python_code`（Python 代码）。

## 为什么要使用 DSPy 签名？

为了模块化和整洁的代码，其中 LM 调用可以被优化为高质量的提示（或自动微调）。大多数人通过编写长而脆弱的提示来强制 LM 执行任务。或者通过收集/生成数据进行微调。编写签名比编写提示或微调更模块化、更具适应性和可重现性。DSPy 编译器会找出如何为你的 LM（或微调你的小 LM）针对你的签名、在你的数据上、在你的管道内构建高度优化的提示。在许多情况下，我们发现编译产生的提示比人类编写的更好。这并不是因为 DSPy 优化器比人类更有创造力，而仅仅是因为它们可以尝试更多的事情并直接调整指标。

## **内联** DSPy 签名

签名可以定义为一个短字符串，带有参数名称和可选类型，定义输入/输出的语义角色。

1. 问答：`"question -> answer"`，这等同于 `"question: str -> answer: str"`，因为默认类型总是 `str`

2. 情感分类：`"sentence -> sentiment: bool"`，例如如果是积极的则为 `True`

3. 摘要：`"document -> summary"`

你的签名也可以有多个带类型的输入/输出字段：

4. 检索增强问答：`"context: list[str], question: str -> answer: str"`

5. 带推理的多项选择问答：`"question, choices: list[str] -> reasoning: str, selection: int"`

**提示：** 对于字段，任何有效的变量名都可以！字段名应该具有语义意义，但从简单的开始，不要过早优化关键词！把这种黑客行为留给 DSPy 编译器。例如，对于摘要，说 `"document -> summary"`、`"text -> gist"` 或 `"long_context -> tldr"` 可能都是可以的。

你还可以向内联签名添加指令，这些指令可以在运行时使用变量。使用 `instructions` 关键字参数向你的签名添加指令。

```python
toxicity = dspy.Predict(
    dspy.Signature(
        "comment -> toxic: bool",
        instructions="Mark as 'toxic' if the comment includes insults, harassment, or sarcastic derogatory remarks.",
    )
)
comment = "you are beautiful."
toxicity(comment=comment).toxic
```

**输出:**
```text
False
```


### 示例 A: 情感分类

```python
sentence = "it's a charming and often affecting journey."  # 来自 SST-2 数据集的示例。

classify = dspy.Predict('sentence -> sentiment: bool')  # 我们稍后会看到一个带有 Literal[] 的例子
classify(sentence=sentence).sentiment
```
**输出:**
```text
True
```

### 示例 B: 摘要

```python
# 来自 XSum 数据集的示例。
document = """The 21-year-old made seven appearances for the Hammers and netted his only goal for them in a Europa League qualification round match against Andorran side FC Lustrains last season. Lee had two loan spells in League One last term, with Blackpool and then Colchester United. He scored twice for the U's but was unable to save them from relegation. The length of Lee's contract with the promoted Tykes has not been revealed. Find all the latest football transfers on our dedicated page."""

summarize = dspy.ChainOfThought('document -> summary')
response = summarize(document=document)

print(response.summary)
```
**可能的输出:**
```text
The 21-year-old Lee made seven appearances and scored one goal for West Ham last season. He had loan spells in League One with Blackpool and Colchester United, scoring twice for the latter. He has now signed a contract with Barnsley, but the length of the contract has not been revealed.
```

许多 DSPy 模块（`dspy.Predict` 除外）通过在幕后扩展你的签名来返回辅助信息。

例如，`dspy.ChainOfThought` 还在生成输出 `summary` 之前添加了一个 `reasoning` 字段，其中包含 LM 的推理。

```python
print("Reasoning:", response.reasoning)
```
**可能的输出:**
```text
Reasoning: We need to highlight Lee's performance for West Ham, his loan spells in League One, and his new contract with Barnsley. We also need to mention that his contract length has not been disclosed.
```

## **基于类**的 DSPy 签名

对于某些高级任务，你需要更详细的签名。这通常是为了：

1. 澄清任务性质的某些方面（在下面表示为 `docstring`）。

2. 提供关于输入字段性质的提示，表示为 `dspy.InputField` 的 `desc` 关键字参数。

3. 提供对输出字段的约束，表示为 `dspy.OutputField` 的 `desc` 关键字参数。

### 示例 C: 分类

```python
from typing import Literal

class Emotion(dspy.Signature):
    """Classify emotion."""
    
    sentence: str = dspy.InputField()
    sentiment: Literal['sadness', 'joy', 'love', 'anger', 'fear', 'surprise'] = dspy.OutputField()

sentence = "i started feeling a little vulnerable when the giant spotlight started blinding me"  # 来自 dair-ai/emotion

classify = dspy.Predict(Emotion)
classify(sentence=sentence)
```
**可能的输出:**
```text
Prediction(
    sentiment='fear'
)
```

**提示：** 更清楚地向 LM 指定你的请求没有任何问题。基于类的签名可以帮助你做到这一点。但是，不要过早地手动调整签名的关键词。DSPy 优化器可能会做得更好（并且将在 LM 之间更好地迁移）。

### 示例 D: 评估引用忠实度的指标

```python
class CheckCitationFaithfulness(dspy.Signature):
    """Verify that the text is based on the provided context."""

    context: str = dspy.InputField(desc="facts here are assumed to be true")
    text: str = dspy.InputField()
    faithfulness: bool = dspy.OutputField()
    evidence: dict[str, list[str]] = dspy.OutputField(desc="Supporting evidence for claims")

context = "The 21-year-old made seven appearances for the Hammers and netted his only goal for them in a Europa League qualification round match against Andorran side FC Lustrains last season. Lee had two loan spells in League One last term, with Blackpool and then Colchester United. He scored twice for the U's but was unable to save them from relegation. The length of Lee's contract with the promoted Tykes has not been revealed. Find all the latest football transfers on our dedicated page."

text = "Lee scored 3 goals for Colchester United."

faithfulness = dspy.ChainOfThought(CheckCitationFaithfulness)
faithfulness(context=context, text=text)
```
**可能的输出:**
```text
Prediction(
    reasoning="Let's check the claims against the context. The text states Lee scored 3 goals for Colchester United, but the context clearly states 'He scored twice for the U's'. This is a direct contradiction.",
    faithfulness=False,
    evidence={'goal_count': ["scored twice for the U's"]}
)
```

### 示例 E: 多模态图像分类

```python
class DogPictureSignature(dspy.Signature):
    """Output the dog breed of the dog in the image."""
    image_1: dspy.Image = dspy.InputField(desc="An image of a dog")
    answer: str = dspy.OutputField(desc="The dog breed of the dog in the image")

image_url = "https://picsum.photos/id/237/200/300"
classify = dspy.Predict(DogPictureSignature)
classify(image_1=dspy.Image.from_url(image_url))
```

**可能的输出:**

```text
Prediction(
    answer='Labrador Retriever'
)
```

## 签名中的类型解析

DSPy 签名支持各种注释类型：

1. **基本类型** 如 `str`, `int`, `bool`
2. **Typing 模块类型** 如 `list[str]`, `dict[str, int]`, `Optional[float]`, `Union[str, int]`
3. **自定义类型** 在你的代码中定义
4. **点符号** 用于具有适当配置的嵌套类型
5. **特殊数据类型** 如 `dspy.Image, dspy.History`

### 使用自定义类型

```python
# 简单的自定义类型
class QueryResult(pydantic.BaseModel):
    text: str
    score: float

signature = dspy.Signature("query: str -> result: QueryResult")

class MyContainer:
    class Query(pydantic.BaseModel):
        text: str
    class Score(pydantic.BaseModel):
        score: float

signature = dspy.Signature("query: MyContainer.Query -> score: MyContainer.Score")
```

## 使用签名构建模块并编译它们

虽然签名对于使用结构化输入/输出进行原型设计很方便，但这并不是使用它们的唯一原因！

你应该将多个签名组合成更大的 DSPy 模块，并将这些模块编译为优化的提示和微调。