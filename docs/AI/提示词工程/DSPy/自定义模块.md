本指南将带您了解如何通过自定义 `dspy.Module` 来构建 GenAI 应用程序。

[DSPy 模块](https://dspy.ai/learn/programming/modules/) 是 DSPy 程序的基本构建块。

* 每个内置模块都抽象了一种提示技术（如思维链或 ReAct）。关键在于，它们被泛化以处理任何签名（signature）。
* 一个 DSPy 模块拥有可学习的参数（即构成提示词的小片段和 LM 权重），并且可以被调用以处理输入并返回输出。
* 多个模块可以组合成更大的模块（程序）。DSPy 模块的设计直接灵感来源于 PyTorch 中的神经网络模块，但应用于 LM 程序。

虽然您可以在不实现自定义模块的情况下构建 DSPy 程序，但我们强烈建议将您的逻辑放在自定义模块中，以便您可以使用其他 DSPy 功能，如 DSPy 优化器或 MLflow DSPy 追踪。

在开始之前，请确保您已安装 DSPy：

```
!pip install dspy

```

推荐：设置 MLflow 追踪以了解底层发生了什么。

### MLflow DSPy 集成

[MLflow](https://mlflow.org/) 是一个 LLMOps 工具，它原生集成在 DSPy 中，提供可解释性和实验跟踪。在本教程中，您可以使用 MLflow 将提示词和优化进度可视化为追踪（traces），以便更好地理解 DSPy 的行为。您可以按照以下四个步骤轻松设置 MLflow。

1. 安装 MLflow

```
%pip install mlflow>=3.0.0

```

2. 在单独的终端中启动 MLflow UI

```
mlflow ui --port 5000 --backend-store-uri sqlite:///mlruns.db

```

3. 将笔记本连接到 MLflow

```
import mlflow

mlflow.set_tracking_uri("http://localhost:5000")
mlflow.set_experiment("DSPy")

```

4. 启用追踪

```
mlflow.dspy.autolog()

```

要了解有关集成的更多信息，请访问 [MLflow DSPy 文档](https://mlflow.org/docs/latest/llms/dspy/index.html)。

## 自定义 DSPy 模块

通过自定义 DSPy 模块，您可以实现自定义提示逻辑并集成外部工具或服务。为此，请继承 `dspy.Module` 并实现以下两个关键方法：

* `__init__`：这是构造函数，您在此定义程序的属性和子模块。
* `forward`：此方法包含您的 DSPy 核心逻辑。

在 `forward()` 方法中，您不仅限于调用其他 DSPy 模块；您还可以集成任何标准的 Python 函数，例如用于与 Langchain/Agno 代理、MCP 工具、数据库处理程序等进行交互的函数。

自定义 DSPy 模块的基本结构如下所示：

```
class MyProgram(dspy.Module):

    def __init__(self, ...):
        # 在此定义属性和子模块
        {constructor_code}

    def forward(self, input_name1, input_name2, ...):
        # 在此实现您的程序逻辑
        {custom_logic_code}

```

让我们用一个实际的代码示例来说明这一点。我们将构建一个包含多个阶段的简单检索增强生成 (RAG) 应用程序：

1. **查询生成：** 根据用户的问题生成合适的查询，以检索相关上下文。
2. **上下文检索：** 使用生成的查询获取上下文。
3. **答案生成：** 根据检索到的上下文和原始问题生成最终答案。

此多阶段程序的代码实现如下所示。

```
import dspy

class QueryGenerator(dspy.Signature):
    """Generate a query based on question to fetch relevant context"""
    question: str = dspy.InputField()
    query: str = dspy.OutputField()

def search_wikipedia(query: str) -> list[str]:
    """Query ColBERT endpoint, which is a knowledge source based on wikipedia data"""
    results = dspy.ColBERTv2(url='http://20.102.90.50:2017/wiki17_abstracts')(query, k=1)
    return [x["text"] for x in results]

class RAG(dspy.Module):
    def __init__(self):
        self.query_generator = dspy.Predict(QueryGenerator)
        self.answer_generator = dspy.ChainOfThought("question,context->answer")

    def forward(self, question, **kwargs):
        query = self.query_generator(question=question).query
        context = search_wikipedia(query)[0]
        return self.answer_generator(question=question, context=context).answer

```

让我们看一下 `forward` 方法。我们首先将问题发送给 `self.query_generator`（这是一个 `dspy.Predict`），以获取用于检索上下文的查询。然后，我们使用该查询调用 ColBERT 并保留检索到的第一个上下文。最后，我们将问题和上下文发送到 `self.answer_generator`（这是一个 `dspy.ChainOfThought`）以生成最终答案。

接下来，我们将创建 `RAG` 模块的一个实例来运行程序。

**重要提示：** 调用自定义 DSPy 模块时，应直接使用模块实例（内部调用 `__call__` 方法），而不是显式调用 `forward()` 方法。`__call__` 方法在执行 `forward` 逻辑之前会处理必要的内部流程。

```
import os

os.environ["OPENAI_API_KEY"] = "{your_openai_api_key}"

dspy.configure(lm=dspy.LM("openai/gpt-4o-mini"))
rag = RAG()
print(rag(question="Is Lebron James the basketball GOAT?"))

```

```
The question of whether LeBron James is the basketball GOAT is subjective and depends on personal opinions. Many consider him one of the greatest due to his achievements and impact on the game, but others may argue for different players like Michael Jordan.

```

就是这样！总之，要构建您的 GenAI 应用程序，我们只需将自定义逻辑放入 `forward()` 方法中，然后创建模块实例并调用该实例本身。

## 为什么要自定义模块？

DSPy 是一个轻量级的创作和优化框架，我们的重点是通过将提示（字符串输入，字符串输出）LLM 转变为编程 LLM（结构化输入，结构化输出），从而解决提示工程的混乱问题，以构建健壮的 AI 系统。

虽然我们提供了具有自定义提示逻辑的预构建模块（如用于推理的 `dspy.ChainOfThought`，用于工具调用代理的 `dspy.ReAct`）以方便您构建 AI 应用程序，但我们的目标并不是标准化您构建代理的方式。

在 DSPy 中，您的应用程序逻辑只需放入自定义模块的 `forward` 方法中，只要您编写的是 Python 代码，就没有与其它的约束。通过这种布局，DSPy 很容易从其他框架或原生 SDK 用法迁移过来，也很容易迁移出去，因为本质上它只是 Python 代码。

### 💡 核心总结：为什么你需要自定义模块？

如果你还在犹豫是否要自定义模块，请记住以下三点核心价值：

1.  **为了“自动优化”**：这是 DSPy 最强大的功能。只有将逻辑封装在模块中，DSPy 的编译器（Optimizers）才能“看懂”你的程序流程，进而自动帮你调整 Prompt 和少样本示例（Few-Shot Examples），从而在不改代码的情况下提升效果。
2.  **为了“看得清楚”**：自定义模块天然支持 MLflow 等追踪工具。当你的 AI 应用变得复杂（例如包含多次搜索、推理）时，模块化能让你清晰地看到每一步的输入输出，极大地降低调试难度。
3.  **为了“像写代码一样写 AI”**：抛弃凌乱的字符串拼接。通过自定义模块，你可以用标准的 Python 类和方法来组织 LLM 逻辑，并在其中随意穿插数据库查询、API 调用等传统代码，让 AI 应用的开发回归软件工程的严谨与灵活。

一句话：**自定义模块是通往 DSPy 自动化优化和生产级可观测性的唯一入口。**
