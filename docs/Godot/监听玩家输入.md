---
sidebar_position: 12
---

在上一课 [编写你的第一个脚本](编写你的第一个脚本.md) 的基础上，让我们看看任何游戏中的另一个重要功能：将控制权交给玩家。为了实现这一点，我们需要修改我们的 `sprite_2d.gd` 代码。

![Moving with input](https://docs.godotengine.org/en/stable/_images/scripting_first_script_moving_with_input.gif)

在 Godot 中，你有两个主要的工具来处理玩家的输入：

1.  内置的输入回调，主要是 `_unhandled_input()`。和 `_process()` 一样，它是一个内置的虚函数，每当玩家按下按键时 Godot 都会调用它。它是你用来响应非每帧发生的事件（例如按空格键跳跃）的工具。要了解更多关于输入回调的信息，请参阅 [使用 InputEvent](https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html)。
2.  `Input` 单例 (singleton)。单例是一个全局可访问的对象。Godot 在脚本中提供了对多个单例的访问。它是每帧检查输入的正确工具。

我们将在这里使用 `Input` 单例，因为我们需要每帧知道玩家是否想要转向或移动。

对于转向，我们应该使用一个新变量：`direction`。在我们的 `_process()` 函数中，将 `rotation += angular_speed * delta` 这一行替换为下面的代码。

```gdscript
var direction = 0
if Input.is_action_pressed("ui_left"):
	direction = -1
if Input.is_action_pressed("ui_right"):
	direction = 1

rotation += angular_speed * direction * delta
```

```csharp
var direction = 0;
if (Input.IsActionPressed("ui_left"))
{
    direction = -1;
}
if (Input.IsActionPressed("ui_right"))
{
    direction = 1;
}

Rotation += _angularSpeed * direction * (float)delta;
```

我们的 `direction` 局部变量是一个代表玩家想要转向的方向的乘数。值 `0` 表示玩家没有按下左或右方向键。值 `1` 表示玩家想要向右转，而 `-1` 表示他们想要向左转。

为了产生这些值，我们引入了条件语句和 `Input` 的使用。在 GDScript 中，条件语句以 `if` 关键字开头，以冒号结束。条件具体是指关键字和行尾冒号之间的表达式。

要检查本帧是否按下了某个键，我们调用 `Input.is_action_pressed()`。该方法接受一个代表输入动作的字符串，并在按下该动作时返回 `true`，否则返回 `false`。

我们上面使用的两个动作 “ui_left” 和 “ui_right” 在每个 Godot 项目中都是预定义的。当玩家按下键盘上的左右方向键或游戏手柄上的方向键左右时，它们会分别触发。

> **注意**
>
> 你可以通过转到 **项目 > 项目设置** 并点击 **输入映射 (Input Map)** 选项卡来查看和编辑项目中的输入动作。

最后，我们在更新节点的 `rotation` 时将 `direction` 用作乘数：`rotation += angular_speed * direction * delta`。

像这样注释掉 `var velocity = Vector2.UP.rotated(rotation) * speed` 和 `position += velocity * delta` 这两行：

```gdscript
#var velocity = Vector2.UP.rotated(rotation) * speed
#position += velocity * delta
```

```csharp
//var velocity = Vector2.Up.Rotated(Rotation) * _speed;
//Position += velocity * (float)delta;
```

这将忽略上一练习中在没有用户输入的情况下让图标圆周运动的代码。

如果你运行包含此代码的场景，图标应该会在你按下左右键时旋转。

## 按下 “上” 时移动

为了仅在按下按键时移动，我们需要修改计算速度的代码。取消代码注释，并将以 `var velocity` 开头的行替换为下面的代码。

```gdscript
var velocity = Vector2.ZERO
if Input.is_action_pressed("ui_up"):
	velocity = Vector2.UP.rotated(rotation) * speed
```

```csharp
var velocity = Vector2.Zero;
if (Input.IsActionPressed("ui_up"))
{
    velocity = Vector2.Up.Rotated(Rotation) * _speed;
}
```

我们使用 `Vector2.ZERO` 初始化 `velocity`，这是内置 `Vector` 类型的另一个常量，代表长度为 0 的 2D 向量。

如果玩家按下 “ui_up” 动作，我们随后会更新速度的值，使精灵向前移动。

## 完整脚本

这里提供完整的 `sprite_2d.gd` 文件供参考。

```gdscript
extends Sprite2D

var speed = 400
var angular_speed = PI

func _process(delta):
	var direction = 0
	if Input.is_action_pressed("ui_left"):
		direction = -1
	if Input.is_action_pressed("ui_right"):
		direction = 1

	rotation += angular_speed * direction * delta

	var velocity = Vector2.ZERO
	if Input.is_action_pressed("ui_up"):
		velocity = Vector2.UP.rotated(rotation) * speed

	position += velocity * delta
```

```csharp
using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Process(double delta)
    {
        var direction = 0;
        if (Input.IsActionPressed("ui_left"))
        {
            direction = -1;
        }
        if (Input.IsActionPressed("ui_right"))
        {
            direction = 1;
        }

        Rotation += _angularSpeed * direction * (float)delta;

        var velocity = Vector2.Zero;
        if (Input.IsActionPressed("ui_up"))
        {
            velocity = Vector2.Up.Rotated(Rotation) * _speed;
        }

        Position += velocity * (float)delta;
    }
}
```

如果你运行场景，你现在应该能够使用左右方向键旋转，并通过按下向上方向键向前移动。

![Moving with input](https://docs.godotengine.org/en/stable/_images/scripting_first_script_moving_with_input.gif)

## 总结

综上所述，Godot 中的每个脚本都代表一个类，并扩展了引擎的内置类之一。你的类继承自的节点类型让你能够访问属性，例如在我们的精灵案例中的 `rotation` 和 `position`。你还继承了许多函数，我们在本示例中没有用到它们。

在 GDScript 中，你放在文件顶部的变量是你的类的属性，也称为成员变量。除了变量之外，你还可以定义函数，在大多数情况下，它们将是你的类的方法。

Godot 提供了几个虚函数，你可以定义它们来将你的类与引擎连接起来。其中包括 `_process()`（每帧对节点应用更改）和 `_unhandled_input()`（接收来自用户的键盘和按钮按下等输入事件）。还有不少其它的。

`Input` 单例允许你在代码中的任何位置对玩家的输入做出反应。特别是，你会在 `_process()` 循环中使用它。

在下一课 [使用信号](使用信号.md) 中，我们将通过让节点触发脚本中的代码，进一步构建脚本与节点之间的关系。
