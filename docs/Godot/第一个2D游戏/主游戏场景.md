---
sidebar_position: 6
---

现在是时候将我们所做的一切整合到一个可玩的游戏场景中了。

创建一个新场景并添加一个名为 `Main` 的 [Node](https://docs.godotengine.org/en/stable/classes/class_node.html)。（我们使用 `Node` 而不是 `Node2D` 的原因是这个节点将作为处理游戏逻辑的容器。它本身不需要 2D 功能。）

点击 **实例化 (Instance)** 按钮（由链条图标表示）并选择你保存的 `player.tscn`。

![Instance Scene](https://docs.godotengine.org/en/stable/_images/instance_scene.webp)

现在，添加以下节点作为 `Main` 的子节点，并按如下所示命名：

*   [Timer](https://docs.godotengine.org/en/stable/classes/class_timer.html) (命名为 `MobTimer`) —— 用于控制小怪生成的频率。
*   [Timer](https://docs.godotengine.org/en/stable/classes/class_timer.html) (命名为 `ScoreTimer`) —— 用于每秒增加分数。
*   [Timer](https://docs.godotengine.org/en/stable/classes/class_timer.html) (命名为 `StartTimer`) —— 用于在开始前提供延迟。
*   [Marker2D](https://docs.godotengine.org/en/stable/classes/class_marker2d.html) (命名为 `StartPosition`) —— 用于指示玩家的起始位置。

按如下方式设置每个 `Timer` 节点的 `Wait Time` (等待时间) 属性（单位为秒）：

*   `MobTimer`: `0.5`
*   `ScoreTimer`: `1`
*   `StartTimer`: `2`

此外，将 `StartTimer` 的 `One Shot` (单次) 属性设置为 “启用”，并将 `StartPosition` 节点的 `Position` 设置为 `(240, 450)`。

## 生成小怪 (Spawning mobs)

`Main` 节点将负责生成新的小怪，我们希望它们出现在屏幕边缘的随机位置。点击场景面板中的 `Main` 节点，然后添加一个名为 `MobPath` 的 [Path2D](https://docs.godotengine.org/en/stable/classes/class_path2d.html) 子节点。当你选中 `Path2D` 时，你会看到编辑器顶部出现了一些新按钮：

![Path2D Buttons](https://docs.godotengine.org/en/stable/_images/path2d_buttons.webp)

选择中间那个（“添加点”），并通过点击在所示的角落添加点来绘制路径。为了让点对齐网格，请确保同时选中了 “使用网格捕捉 (Use Grid Snap)” 和 “使用智能捕捉 (Use Smart Snap)”。这些选项位于 “锁定” 按钮左侧，分别显示为磁铁旁边有小点和交叉线的图标。

![Grid Snap Button](https://docs.godotengine.org/en/stable/_images/grid_snap_button.webp)

> **重要**
>
> 请按 **顺时针** 方向绘制路径，否则你的小怪会向 **外** 发射而不是向 **内** 发射！

![Draw Path2D](https://docs.godotengine.org/en/stable/_images/draw_path2d.gif)

在图中放置第 `4` 个点后，点击 “闭合曲线 (Close Curve)” 按钮，你的曲线就完成了。

既然路径已经定义好了，添加一个 [PathFollow2D](https://docs.godotengine.org/en/stable/classes/class_pathfollow2d.html) 节点作为 `MobPath` 的子节点，并命名为 `MobSpawnLocation`。这个节点在移动时会自动旋转并跟随路径，因此我们可以用它来沿着路径选择随机的位置和方向。

你的场景现在应该是这样的：

![Main Scene Nodes](https://docs.godotengine.org/en/stable/_images/main_scene_nodes.webp)

## 主脚本 (Main script)

为 `Main` 添加一个脚本。在脚本顶部，我们使用 `@export var mob_scene: PackedScene` 来允许我们选择想要实例化的小怪场景。

```gdscript
extends Node

@export var mob_scene: PackedScene
var score
```

```csharp
using Godot;

public partial class Main : Node
{
    // 别忘了重新构建项目，以便编辑器知道新的导出变量。

    [Export]
    public PackedScene MobScene { get; set; }

    private int _score;
}
```

点击 `Main` 节点，你会看到检查器中 “Main.gd” 下出现了 `Mob Scene` 属性。

你可以通过两种方式为该属性赋值：

*   从 “文件系统” 面板将 `mob.tscn` 拖放到 **Mob Scene** 属性中。
*   点击 “[空]” 旁边的下箭头并选择 “加载 (Load)”，然后选择 `mob.tscn`。

接下来，在场景面板中选中 `Main` 节点下的 `Player` 场景实例，并打开侧边栏的 “节点” 面板。确保选中了 “信号” 选项卡。

你应该能看到 `Player` 节点的信号列表。在列表中找到并双击 `hit` 信号（或右键点击它并选择 “连接...”）。这将打开信号连接对话框。我们要创建一个名为 `game_over` 的新函数，它将处理游戏结束时需要发生的事情。在对话框底部的 “接收方法 (Receiver Method)” 框中输入 “game_over” 并点击 “连接”。你的目标是让 `Player` 发出 `hit` 信号并在 `Main` 脚本中处理它。在函数中添加以下代码，并添加一个 `new_game` 函数来为新游戏做好准备：

```gdscript
func game_over():
	$ScoreTimer.stop()
	$MobTimer.stop()

func new_game():
	score = 0
	$Player.start($StartPosition.position)
	$StartTimer.start()
```

```csharp
public void GameOver()
{
    GetNode<Timer>("MobTimer").Stop();
    GetNode<Timer>("ScoreTimer").Stop();
}

public void NewGame()
{
    _score = 0;

    var player = GetNode<Player>("Player");
    var startPosition = GetNode<Marker2D>("StartPosition");
    player.Start(startPosition.Position);

    GetNode<Timer>("StartTimer").Start();
}
```

现在我们将每个 Timer 节点（`StartTimer`、`ScoreTimer` 和 `MobTimer`）的 `timeout()` 信号连接到主脚本。对于这三个定时器，分别在场景面板中选中它们，打开 “节点” 面板的 “信号” 选项卡，然后双击列表中的 `timeout()` 信号。默认设置即可，点击 **连接 (Connect)** 创建新的信号连接。

完成这三个定时器的设置后，你应该能在它们各自的信号选项卡中看到每个定时器的 `timeout()` 信号都有一个绿色的连接：

*   （对于 MobTimer）：`_on_mob_timer_timeout()`
*   （对于 ScoreTimer）：`_on_score_timer_timeout()`
*   （对于 StartTimer）：`_on_start_timer_timeout()`

现在我们通过添加下面的代码来定义这些定时器的运行方式。注意 `StartTimer` 将启动另外两个定时器，而 `ScoreTimer` 将使分数增加 1。

```gdscript
func _on_score_timer_timeout():
	score += 1

func _on_start_timer_timeout():
	$MobTimer.start()
	$ScoreTimer.start()
```

```csharp
// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnScoreTimerTimeout()
{
    _score++;
}

// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnStartTimerTimeout()
{
    GetNode<Timer>("MobTimer").Start();
    GetNode<Timer>("ScoreTimer").Start();
}
```

在 `_on_mob_timer_timeout()` 中，我们将创建一个小怪实例，沿着 `Path2D` 选择一个随机的起始位置，并让小怪开始移动。`PathFollow2D` 节点在跟随路径时会自动旋转，因此我们将利用这一点来选择小怪的方向和位置。生成小怪时，我们将为其移动速度选取一个 `150.0` 到 `250.0` 之间的随机值（如果速度都一样就太无聊了）。

注意，必须使用 `add_child()` 将新实例添加到场景中。

```gdscript
func _on_mob_timer_timeout():
	# 创建小怪场景的新实例。
	var mob = mob_scene.instantiate()

	# 在 Path2D 上选择一个随机位置。
	var mob_spawn_location = $MobPath/MobSpawnLocation
	mob_spawn_location.progress_ratio = randf()

	# 将小怪的位置设置为随机位置。
	mob.position = mob_spawn_location.position

	# 设置小怪的方向垂直于路径方向。
	var direction = mob_spawn_location.rotation + PI / 2

	# 为方向添加一些随机性。
	direction += randf_range(-PI / 4, PI / 4)
	mob.rotation = direction

	# 为小怪选择速度。
	var velocity = Vector2(randf_range(150.0, 250.0), 0.0)
	mob.linear_velocity = velocity.rotated(direction)

	# 通过将小怪添加到 Main 场景中来生成它。
	add_child(mob)
```

```csharp
// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnMobTimerTimeout()
{
    // 创建小怪场景的新实例。
    Mob mob = MobScene.Instantiate<Mob>();

    // 在 Path2D 上选择一个随机位置。
    var mobSpawnLocation = GetNode<PathFollow2D>("MobPath/MobSpawnLocation");
    mobSpawnLocation.ProgressRatio = GD.Randf();

    // 设置小怪的方向垂直于路径方向。
    float direction = mobSpawnLocation.Rotation + Mathf.Pi / 2;

    // 将小怪的位置设置为随机位置。
    mob.Position = mobSpawnLocation.Position;

    // 为方向添加一些随机性。
    direction += (float)GD.RandRange(-Mathf.Pi / 4, Mathf.Pi / 4);
    mob.Rotation = direction;

    // 选择速度。
    var velocity = new Vector2((float)GD.RandRange(150.0, 250.0), 0);
    mob.LinearVelocity = velocity.Rotated(direction);

    // 通过将小怪添加到 Main 场景中来生成它。
    AddChild(mob);
}
```

> **重要**
>
> 为什么用 `PI`？在需要角度的函数中，Godot 使用 **弧度 (radians)**，而不是角度。Pi 代表弧度制中的半圈，大约为 `3.1415`（还有 `TAU`，等于 `2 * PI`）。如果你更习惯使用角度，则需要使用 `deg_to_rad()` 和 `rad_to_deg()` 函数在两者之间进行转换。

## 测试场景 (Testing the scene)

让我们测试一下场景，确保一切正常。在 `_ready()` 中添加 `new_game` 调用：

```gdscript
func _ready():
	new_game()
```

```csharp
public override void _Ready()
{
    NewGame();
}
```

让我们还将 `Main` 分配为我们的 “主场景” —— 即游戏启动时自动运行的场景。按下 “运行项目” 按钮，并在提示时选择 `main.tscn`。

> **提示**
>
> 如果你已经设置了另一个场景作为 “主场景”，可以在 “文件系统” 面板中右键点击 `main.tscn` 并选择 **设为主场景 (Set As Main Scene)**。

你应该能够移动玩家，看到小怪生成，并看到玩家在被小怪击中时消失。

当你确定一切正常后，从 `_ready()` 中删除对 `new_game()` 的调用，并用 `pass` 替换它。

我们的游戏还缺少什么？一些用户界面。在下一课中，我们将添加标题屏幕并显示玩家的分数。
