---
sidebar_position: 7
---

我们游戏需要的最后一部分是用户界面 (UI)，用于显示分数、“游戏结束” 消息和重新开始按钮。

创建一个新场景，点击 “其它节点” 按钮并添加一个名为 `HUD` 的 [CanvasLayer](https://docs.godotengine.org/en/stable/classes/class_canvaslayer.html) 节点。“HUD” 代表 “抬头显示 (heads-up display)”，是一种叠加在游戏视图之上的信息显示。

[CanvasLayer](https://docs.godotengine.org/en/stable/classes/class_canvaslayer.html) 节点允许我们在游戏其余部分之上的层级绘制 UI 元素，这样它显示的信息就不会被玩家或小怪等任何游戏元素遮挡。

HUD 需要显示以下信息：

*   由 `ScoreTimer` 更改的分数。
*   一条消息，例如 “Game Over” 或 “Get Ready!”。
*   一个用于开始游戏的 “Start” 按钮。

UI 元素的基础节点是 [Control](https://docs.godotengine.org/en/stable/classes/class_control.html)。为了创建我们的 UI，我们将使用两种类型的 `Control` 节点：[Label](https://docs.godotengine.org/en/stable/classes/class_label.html) (标签) 和 [Button](https://docs.godotengine.org/en/stable/classes/class_button.html) (按钮)。

在 `HUD` 节点下创建以下子节点：

*   名为 `ScoreLabel` 的 `Label`。
*   名为 `Message` 的 `Label`。
*   名为 `StartButton` 的 `Button`。
*   名为 `MessageTimer` 的 `Timer`。

点击 `ScoreLabel` 并在检查器的 `Text` 字段中输入一个数字。`Control` 节点的默认字体较小且缩放效果不佳。游戏资产中包含一个名为 “Xolonium-Regular.ttf” 的字体文件。要使用此字体，请执行以下操作：

在 **Theme Overrides > Fonts** 下，选择 “加载 (Load)” 并选择 “Xolonium-Regular.ttf” 文件。

![Load Custom Font](https://docs.godotengine.org/en/stable/_images/custom_font_load_font.webp)

字体大小仍然太小，在 **Theme Overrides > Font Sizes** 下将其增加到 `64`。完成 `ScoreLabel` 的设置后，对 `Message` 和 `StartButton` 节点重复这些更改。

![Custom Font Size](https://docs.godotengine.org/en/stable/_images/custom_font_size.webp)

> **注意**
>
> **锚点 (Anchors):** `Control` 节点具有位置和大小，但它们也有锚点。锚点定义了原点——即节点边缘的参考点。

如下图所示排列节点。你可以拖动节点进行手动放置，或者为了更精确的放置，使用 “锚点预设 (Anchor Presets)”。

![UI Anchor](https://docs.godotengine.org/en/stable/_images/ui_anchor.webp)

## ScoreLabel

1.  添加文本 `0`。
2.  将 “Horizontal Alignment” (水平对齐) 和 “Vertical Alignment” (垂直对齐) 设置为 `Center` (居中)。
3.  选择锚点预设 **Center Top** (顶部居中)。

## Message

1.  添加文本 `Dodge the Creeps!`。
2.  将 “Horizontal Alignment” 和 “Vertical Alignment” 设置为 `Center`。
3.  将 “Autowrap Mode” (自动换行模式) 设置为 `Word` (单词)，否则标签将保持在一行。
4.  在 **Control - Layout/Transform** 下将 “Size X” 设置为 `480`，以使用屏幕的整个宽度。
5.  选择锚点预设 **Center** (正中心)。

## StartButton

1.  添加文本 `Start`。
2.  在 **Control - Layout/Transform** 下，将 “Size X” 设置为 `200`， “Size Y” 设置为 `100`，以便在边框和文本之间添加更多填充。
3.  选择锚点预设 **Center Bottom** (底部居中)。
4.  在 **Control - Layout/Transform** 下，将 “Position Y” 设置为 `580`。

在 `MessageTimer` 上，将 `Wait Time` 设置为 `2` 并将 `One Shot` 属性设置为 “开启”。

现在为 `HUD` 添加此脚本：

```gdscript
extends CanvasLayer

# 通知 `Main` 节点按钮已被按下
signal start_game
```

```csharp
using Godot;

public partial class HUD : CanvasLayer
{
    // 别忘了重新构建项目，以便编辑器知道新信号。

    [Signal]
    public delegate void StartGameEventHandler();
}
```

我们现在想临时显示一条消息，例如 “Get Ready”，因此我们添加以下代码：

```gdscript
func show_message(text):
	$Message.text = text
	$Message.show()
	$MessageTimer.start()
```

```csharp
public void ShowMessage(string text)
{
    var message = GetNode<Label>("Message");
    message.Text = text;
    message.Show();

    GetNode<Timer>("MessageTimer").Start();
}
```

我们还需要处理玩家失败时发生的情况。下面的代码将显示 “Game Over” 2 秒钟，然后返回标题屏幕，并在短暂暂停后显示 “Start” 按钮。

```gdscript
func show_game_over():
	show_message("Game Over")
	# 等待 MessageTimer 倒计时结束。
	await $MessageTimer.timeout

	$Message.text = "Dodge the Creeps!"
	$Message.show()
	# 创建一个一次性定时器并等待它完成。
	await get_tree().create_timer(1.0).timeout
	$StartButton.show()
```

```csharp
async public void ShowGameOver()
{
    ShowMessage("Game Over");

    var messageTimer = GetNode<Timer>("MessageTimer");
    await ToSignal(messageTimer, Timer.SignalName.Timeout);

    var message = GetNode<Label>("Message");
    message.Text = "Dodge the Creeps!";
    message.Show();

    await ToSignal(GetTree().CreateTimer(1.0), SceneTreeTimer.SignalName.Timeout);
    GetNode<Button>("StartButton").Show();
}
```

> **注意**
>
> 当你需要短时间暂停时，除了使用 `Timer` 节点外，另一种选择是使用 SceneTree 的 `create_timer()` 函数。这对于添加延迟非常有用，例如在上面的代码中，我们想在显示 “Start” 按钮之前等待一段时间。

将下面的代码添加到 `HUD` 以更新分数：

```gdscript
func update_score(score):
	$ScoreLabel.text = str(score)
```

```csharp
public void UpdateScore(int score)
{
    GetNode<Label>("ScoreLabel").Text = score.ToString();
}
```

将 `StartButton` 的 `pressed()` 信号和 `MessageTimer` 的 `timeout()` 信号连接到 `HUD` 节点，并在新函数中添加以下代码：

```gdscript
func _on_start_button_pressed():
	$StartButton.hide()
	start_game.emit()

func _on_message_timer_timeout():
	$Message.hide()
```

```csharp
// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnStartButtonPressed()
{
    GetNode<Button>("StartButton").Hide();
    EmitSignal(SignalName.StartGame);
}

// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnMessageTimerTimeout()
{
    GetNode<Label>("Message").Hide();
}
```

## 将 HUD 连接到 Main

既然我们已经完成了 `HUD` 场景的创建，回到 `Main`。像实例化 `Player` 场景一样在 `Main` 中实例化 `HUD` 场景。场景树应该如下所示，请确保没有遗漏任何内容：

![Completed Main Scene](https://docs.godotengine.org/en/stable/_images/completed_main_scene.webp)

现在我们需要将 `HUD` 功能连接到我们的 `Main` 脚本。这需要在 `Main` 场景中进行一些添加：

在 “节点” 选项卡中，通过点击 “连接信号” 窗口中的 “选取 (Pick)” 按钮并选择 `new_game()` 方法，或者在窗口中的 “接收方法” 下方输入 “new_game”，将 HUD 的 `start_game` 信号连接到 Main 节点的 `new_game()` 函数。验证脚本中 `func new_game()` 旁边现在是否出现了绿色的连接图标。

在 `new_game()` 中，更新分数显示并显示 “Get Ready” 消息：

```gdscript
$HUD.update_score(score)
$HUD.show_message("Get Ready")
```

```csharp
var hud = GetNode<HUD>("HUD");
hud.UpdateScore(_score);
hud.ShowMessage("Get Ready!");
```

在 `game_over()` 中，我们需要调用相应的 `HUD` 函数：

```gdscript
$HUD.show_game_over()
```

```csharp
GetNode<HUD>("HUD").ShowGameOver();
```

最后，将此内容添加到 `_on_score_timer_timeout()` 中，以保持显示与不断变化的分数同步：

```gdscript
$HUD.update_score(score)
```

```csharp
GetNode<HUD>("HUD").UpdateScore(_score);
```

> **警告**
>
> 记得从 `_ready()` 中删除对 `new_game()` 的调用（如果还没删的话），否则你的游戏会自动开始。

现在你准备好玩了！点击 “运行项目” 按钮。

## 清除旧的小怪

如果你玩到 “Game Over” 然后立即开始新游戏，上一局的小怪可能仍然留在屏幕上。如果它们在新游戏开始时全部消失会更好。我们只需要一种方法告诉 **所有** 小怪移除自己。我们可以使用 “分组 (group)” 功能来实现这一点。

在 `Mob` 场景中，选择根节点并点击 “信号” 选项卡旁边的 **分组 (Groups)** 选项卡，点击 “+” 按钮打开 “创建新分组” 对话框。

![Group Tab](https://docs.godotengine.org/en/stable/_images/group_tab.webp)

将分组命名为 `mobs` 并点击 “确定” 添加一个新的场景分组。

![Add Group Dialog](https://docs.godotengine.org/en/stable/_images/add_group_dialog.webp)

现在所有小怪都将属于 “mobs” 分组。

![Scene Group Mobs](https://docs.godotengine.org/en/stable/_images/scene_group_mobs.webp)

然后我们可以在 `Main` 的 `new_game()` 函数中添加以下一行：

```gdscript
get_tree().call_group("mobs", "queue_free")
```

```csharp
// 请注意，对于使用字符串调用 Godot 提供的方法，
// 我们必须使用原始的 Godot snake_case 名称。
GetTree().CallGroup("mobs", Node.MethodName.QueueFree);
```

`call_group()` 函数调用分组中每个节点上的指定函数——在这种情况下，我们是在告诉每个小怪删除自己。

此时游戏基本完成了。在下一部分也是最后一部分中，我们将通过添加背景、循环音乐和一些键盘快捷键来对其进行一些润色。
