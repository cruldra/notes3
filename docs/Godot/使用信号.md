---
sidebar_position: 13
---

在本节课中，我们将探讨信号。信号是节点在发生特定事件时发出的消息，例如按钮被按下。其他节点可以连接到该信号，并在事件发生时调用一个函数。

信号是 Godot 内置的一种委托机制，允许一个游戏对象在不引用另一个对象的情况下对另一个对象的更改做出反应。使用信号可以限制 [耦合 (coupling)](https://en.wikipedia.org/wiki/Coupling_(computer_programming)) 并保持代码的灵活性。

例如，你可能在屏幕上有一个代表玩家生命值的生命条。当玩家受到伤害或使用治疗药水时，你希望生命条反映这种变化。在 Godot 中，你会使用信号来实现这一点。

与方法 ([Callable](https://docs.godotengine.org/en/stable/classes/class_callable.html)) 一样，自 Godot 4.0 起，信号也是一等类型 (first-class type)。这意味着你可以直接将它们作为方法参数传递，而无需作为字符串传递，这有助于更好的自动补全并减少错误。有关直接使用 Signal 类型可以执行的操作列表，请参阅 [Signal](https://docs.godotengine.org/en/stable/classes/class_signal.html) 类参考。

> **另见**
>
> 正如简介中所述，信号是 Godot 版本的观察者模式。你可以在 [《游戏编程模式》](https://gameprogrammingpatterns.com/observer.html) 中了解更多相关信息。

现在，我们将使用信号让上一课 ([监听玩家输入](../step_by_step/监听玩家输入.md)) 中的 Godot 图标通过按下按钮来开始和停止移动。

> **注意**
>
> 在这个项目中，我们将遵循 Godot 的命名规范。
>
> *   **GDScript**：类（节点）使用 PascalCase，变量和函数使用 snake_case，常量使用 ALL_CAPS（参见 [GDScript 风格指南](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_styleguide.html)）。
> *   **C#**：类、导出变量和方法使用 PascalCase，私有字段使用 _camelCase，局部变量和参数使用 camelCase（参见 [C# 风格指南](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_style_guide.html)）。在连接信号时，请务必准确输入方法名称。

## 场景设置 (Scene setup)

为了给游戏添加按钮，我们将创建一个新场景，其中包含一个 [Button](https://docs.godotengine.org/en/stable/classes/class_button.html) 节点和我们在 [编写你的第一个脚本](../step_by_step/编写你的第一个脚本.md) 一课中创建的 `sprite_2d.tscn` 场景。

通过菜单 **场景 > 新建场景 (Scene > New Scene)** 创建一个新场景。

![New Scene](https://docs.godotengine.org/en/stable/_images/signals_01_new_scene.webp)

在 “场景” 面板中，点击 **2D 场景 (2D Scene)** 按钮。这将添加一个 `Node2D` 作为我们的根节点。

![2D Scene](https://docs.godotengine.org/en/stable/_images/signals_02_2d_scene.webp)

在 “文件系统 (FileSystem)” 面板中，点击并拖动你之前保存的 `sprite_2d.tscn` 文件到 `Node2D` 上以其实例化。

![Dragging Scene](https://docs.godotengine.org/en/stable/_images/signals_03_dragging_scene.webp)

我们想添加另一个节点作为 `Sprite2D` 的兄弟节点。为此，右键点击 `Node2D` 并选择 **添加子节点 (Add Child Node)**。

![Add Child Node](https://docs.godotengine.org/en/stable/_images/signals_04_add_child_node.webp)

搜索 `Button` 节点并添加它。

![Add Button](https://docs.godotengine.org/en/stable/_images/signals_05_add_button.webp)

该节点默认很小。在视口中点击并拖动 `Button` 的右下角句柄来调整其大小。

![Drag Button](https://docs.godotengine.org/en/stable/_images/signals_06_drag_button.png)

如果你没看到句柄，请确保工具栏中的选择工具已激活。

![Select Tool](https://docs.godotengine.org/en/stable/_images/signals_07_select_tool.webp)

点击并拖动按钮本身，使其靠近精灵。

你还可以通过在检查器中编辑其 `Text` 属性来在按钮上写一个标签。输入 `Toggle motion` (切换运动)。

![Toggle Motion Text](https://docs.godotengine.org/en/stable/_images/signals_08_toggle_motion_text.webp)

你的场景树和视口应该如下所示。

![Scene Setup](https://docs.godotengine.org/en/stable/_images/signals_09_scene_setup.webp)

如果尚未保存，请将新创建的场景保存为 `node_2d.tscn`。然后你可以按 **F6** (macOS 为 **Cmd + R**) 运行它。目前，按钮是可见的，但按下它不会发生任何事情。

## 在编辑器中连接信号 (Connecting a signal in the editor)

这里，我们要将按钮的 “pressed” 信号连接到我们的 `Sprite2D`，并希望调用一个新函数来切换其运动的开启和关闭。我们需要在 `Sprite2D` 节点上附加一个脚本，我们在上一课已经完成了这一操作。

你可以在 “节点 (Node)” 面板中连接信号。选择 `Button` 节点，在编辑器右侧，点击检查器旁边的 **节点 (Node)** 选项卡，然后选择 **信号 (Signals)**。

![Node Dock](https://docs.godotengine.org/en/stable/_images/signals_10_node_dock.webp)

该面板显示了所选节点上可用的信号列表。

![Pressed Signals](https://docs.godotengine.org/en/stable/_images/signals_11_pressed_signals.webp)

双击 “pressed” 信号打开节点连接窗口。

![Node Connection](https://docs.godotengine.org/en/stable/_images/signals_12_node_connection.webp)

在这里，你可以将信号连接到 `Sprite2D` 节点。该节点需要一个接收方法，即当按钮发出信号时 Godot 将调用的函数。编辑器会为你生成一个。按照惯例，我们将这些回调方法命名为 “_on_node_name_signal_name”。在这里，它将是 “_on_button_pressed”。

> **注意**
>
> 通过编辑器的 “节点” 面板连接信号时，你可以使用两种模式。简单模式仅允许你连接到已附加脚本的节点，并在其上创建新的回调函数。
>
> ![Advanced Connection Window](https://docs.godotengine.org/en/stable/_images/signals_advanced_connection_window.webp)
>
> 高级视图允许你连接到任何节点和任何内置函数，为回调添加参数并设置选项。你可以点击窗口右下角的 “高级 (Advanced)” 按钮来切换模式。

> **注意**
>
> 如果你使用的是外部编辑器（如 VS Code），这种自动代码生成可能无法工作。在这种情况下，你需要通过代码连接信号，如下一节所述。

点击 **连接 (Connect)** 按钮完成信号连接并跳转到脚本工作区。你应该会在左侧边栏看到带有连接图标的新方法。

![Signals Connection Icon](https://docs.godotengine.org/en/stable/_images/signals_13_signals_connection_icon.webp)

如果点击该图标，会弹出一个窗口并显示有关连接的信息。此功能仅在编辑器中连接节点时可用。

![Signals Connection Info](https://docs.godotengine.org/en/stable/_images/signals_14_signals_connection_info.webp)

让我们用切换节点运动的代码替换带有 `pass` 关键字的行。

我们的 `Sprite2D` 通过 `_process()` 函数中的代码进行移动。Godot 提供了一个切换处理开启和关闭的方法：[Node.set_process()](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-set-process)。`Node` 类的另一个方法 `is_processing()` 在空闲处理激活时返回 `true`。我们可以使用 `not` 关键字来反转该值。

```gdscript
func _on_button_pressed():
	set_process(not is_processing())
```

```csharp
// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnButtonPressed()
{
    SetProcess(!IsProcessing());
}
```

按下按钮后，此函数将切换处理，进而开启或关闭图标的运动。

在尝试游戏之前，我们需要简化我们的 `_process()` 函数以自动移动节点，而不是等待用户输入。将其替换为我们在两课前看到的以下代码：

```gdscript
func _process(delta):
	rotation += angular_speed * delta
	var velocity = Vector2.UP.rotated(rotation) * speed
	position += velocity * delta
```

```csharp
public override void _Process(double delta)
{
    Rotation += _angularSpeed * (float)delta;
    var velocity = Vector2.Up.Rotated(Rotation) * _speed;
    Position += velocity * (float)delta;
}
```

你的完整 `sprite_2d.gd` 代码应该如下所示：

```gdscript
extends Sprite2D

var speed = 400
var angular_speed = PI

func _process(delta):
	rotation += angular_speed * delta
	var velocity = Vector2.UP.rotated(rotation) * speed
	position += velocity * delta

func _on_button_pressed():
	set_process(not is_processing())
```

```csharp
using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    // 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }
}
```

按 **F6** (macOS 为 **Cmd + R**) 运行当前场景，并点击按钮查看精灵的开始和停止。

## 通过代码连接信号 (Connecting a signal via code)

你可以通过代码而不是使用编辑器来连接信号。当你从脚本内部创建节点或实例化场景时，这是必要的。

让我们在这里使用一个不同的节点。Godot 有一个 [Timer (定时器)](https://docs.godotengine.org/en/stable/classes/class_timer.html) 节点，对于实现技能冷却时间、武器装填等非常有用。

回到 2D 工作区。你可以点击窗口顶部的 “2D” 文本，或者按 **Ctrl + F1** (macOS 为 **Ctrl + Cmd + 1**)。

在 “场景” 面板中，右键点击 `Sprite2D` 节点并添加一个新的子节点。搜索 `Timer` 并添加相应的节点。你的场景现在应该如下所示。

![Scene Tree](https://docs.godotengine.org/en/stable/_images/signals_15_scene_tree.webp)

选中 `Timer` 节点后，前往检查器并启用 **Autostart (自动开始)** 属性。

![Timer Autostart](https://docs.godotengine.org/en/stable/_images/signals_18_timer_autostart.webp)

点击 `Sprite2D` 旁的脚本图标回到脚本工作区。

![Click Script](https://docs.godotengine.org/en/stable/_images/signals_16_click_script.webp)

我们需要执行两个操作来通过代码连接节点：

1.  从 `Sprite2D` 获取对 `Timer` 的引用。
2.  调用 `Timer` 的 “timeout” 信号的 `connect()` 方法。

> **注意**
>
> 要通过代码连接到信号，你需要调用你想监听的信号的 `connect()` 方法。在这种情况下，我们要监听 `Timer` 的 “timeout” 信号。

我们希望在场景实例化时连接信号，我们可以使用 `Node._ready()` 内置函数来完成，该函数在节点完全实例化时由引擎自动调用。

要获取相对于当前节点的节点引用，我们使用 [Node.get_node()](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-get-node) 方法。我们可以将引用存储在一个变量中。

```gdscript
func _ready():
	var timer = get_node("Timer")
```

```csharp
public override void _Ready()
{
    var timer = GetNode<Timer>("Timer");
}
```

`get_node()` 函数查看 `Sprite2D` 的子节点并按名称获取节点。例如，如果你在编辑器中将 `Timer` 节点重命名为 “BlinkingTimer”，你就必须将调用更改为 `get_node("BlinkingTimer")`。

我们现在可以在 `_ready()` 函数中将 `Timer` 连接到 `Sprite2D`。

```gdscript
func _ready():
	var timer = get_node("Timer")
	timer.timeout.connect(_on_timer_timeout)
```

```csharp
public override void _Ready()
{
    var timer = GetNode<Timer>("Timer");
    timer.Timeout += OnTimerTimeout;
}
```

这一行的意思是：我们将 `Timer` 的 “timeout” 信号连接到附加了脚本的节点上。当 `Timer` 发出 `timeout` 信号时，我们希望调用我们需要定义的 `_on_timer_timeout()` 函数。让我们把它添加到脚本底部，并用它来切换精灵的可见性。

> **注意**
>
> 按照惯例，我们在 GDScript 中将这些回调方法命名为 “_on_node_name_signal_name”，在 C# 中命名为 “OnNodeNameSignalName”。在这里，GDScript 为 “_on_timer_timeout”，C# 为 `OnTimerTimeout()`。

```gdscript
func _on_timer_timeout():
	visible = not visible
```

```csharp
private void OnTimerTimeout()
{
    Visible = !Visible;
}
```

`visible` 属性是一个控制节点可见性的布尔值。`visible = not visible` 行会切换该值。如果 `visible` 是 `true`，它就变成 `false`，反之亦然。

如果你现在运行 `Node2D` 场景，你会看到精灵以一秒为间隔闪烁。

## 完整脚本

我们这个会动且会闪烁的 Godot 图标演示到此为止！这里提供完整的 `sprite_2d.gd` 文件供参考。

```gdscript
extends Sprite2D

var speed = 400
var angular_speed = PI

func _ready():
	var timer = get_node("Timer")
	timer.timeout.connect(_on_timer_timeout)

func _process(delta):
	rotation += angular_speed * delta
	var velocity = Vector2.UP.rotated(rotation) * speed
	position += velocity * delta

func _on_button_pressed():
	set_process(not is_processing())

func _on_timer_timeout():
	visible = not visible
```

```csharp
using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Ready()
    {
        var timer = GetNode<Timer>("Timer");
        timer.Timeout += OnTimerTimeout;
    }

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    // 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }

    private void OnTimerTimeout()
    {
        Visible = !Visible;
    }
}
```

## 自定义信号 (Custom signals)

> **注意**
>
> 本节是关于如何定义和使用你自己的信号的参考，并不基于前几课创建的项目。

你可以在脚本中定义自定义信号。例如，假设你想在玩家生命值降至零时显示游戏结束屏幕。为此，你可以定义一个名为 “died” 或 “health_depleted” 的信号。

```gdscript
extends Node2D

signal health_depleted

var health = 10
```

```csharp
using Godot;

public partial class MyNode2D : Node2D
{
    [Signal]
    public delegate void HealthDepletedEventHandler();

    private int _health = 10;
}
```

> **注意**
>
> 由于信号代表刚刚发生的事件，我们通常在它们的名称中使用动词的过去式。

你的信号与内置信号的工作方式相同：它们会出现在 “信号” 选项卡中，你可以像连接其他信号一样连接它们。

![Custom Signal](https://docs.godotengine.org/en/stable/_images/signals_17_custom_signal.webp)

要在脚本中发出信号，请调用该信号的 `emit()`。

```gdscript
func take_damage(amount):
	health -= amount
	if health <= 0:
		health_depleted.emit()
```

```csharp
public void TakeDamage(int amount)
{
    _health -= amount;

    if (_health <= 0)
    {
        EmitSignal(SignalName.HealthDepleted);
    }
}
```

信号可以选择声明一个或多个参数。在括号之间指定参数名称：

```gdscript
extends Node2D

signal health_changed(old_value, new_value)

var health = 10
```

```csharp
using Godot;

public partial class MyNode : Node
{
    [Signal]
    public delegate void HealthChangedEventHandler(int oldValue, int newValue);

    private int _health = 10;
}
```

> **注意**
>
> 信号参数会显示在编辑器的节点面板中，Godot 可以使用它们为你生成回调函数。但是，你在发出信号时仍然可以发出任意数量的参数。因此，发出正确的值取决于你自己。

要连同信号一起发出值，请将它们作为 `emit()` 函数的额外参数添加：

```gdscript
func take_damage(amount):
	var old_health = health
	health -= amount
	health_changed.emit(old_health, health)
```

```csharp
public void TakeDamage(int amount)
{
    int oldHealth = _health;
    _health -= amount;
    EmitSignal(SignalName.HealthChanged, oldHealth, _health);
}
```

## 总结

在 Godot 中，任何节点在发生特定事件时都会发出信号，例如按钮被按下。其他节点可以连接到单个信号并对选定的事件做出反应。

信号有很多用途。使用它们，你可以对节点进入或退出游戏世界、碰撞、角色进入或离开区域、界面元素改变大小等做出反应。

例如，代表金币的 [Area2D](https://docs.godotengine.org/en/stable/classes/class_area2d.html) 每当玩家的物理体进入其碰撞形状时就会发出 `body_entered` 信号，从而让你知道玩家何时收集了它。

在下一节 [你的第一个 2D 游戏](https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html) 中，你将创建一个完整的 2D 游戏，并将你目前学到的所有内容付诸实践。
