> 原文链接：https://bytebytego.com/guides/pessimistic-vs-optimistic-locking/
> 翻译时间：2025-07-10

## 概述

锁机制对于在多用户环境中维护数据一致性和完整性至关重要。它们可以防止同时修改导致的数据不一致问题。

**悲观锁**假设冲突会发生，在进行任何更改之前就锁定数据。它阻止其他用户访问和更新数据，直到锁被释放。

**乐观锁**假设冲突很少发生。它允许多个用户同时访问数据，并在提交更改时检查冲突。如果检测到冲突，操作将被回滚。

## 悲观锁（Pessimistic Locking）

### 工作原理
- 在读取数据时立即加锁
- 防止其他事务修改被锁定的数据
- 直到当前事务完成才释放锁

### 适用场景
- 写操作频繁的系统
- 数据冲突概率高的场景
- 对数据一致性要求极高的业务

### 优点
- 确保数据一致性
- 避免数据冲突
- 简单直接的实现方式

### 缺点
- 可能导致死锁
- 降低系统并发性能
- 锁等待时间可能较长

## 乐观锁（Optimistic Locking）

### 工作原理
- 读取时不加锁，允许并发访问
- 更新时检查数据是否被其他事务修改
- 通常使用版本号或时间戳来检测冲突

### 适用场景
- 读操作频繁的系统
- 数据冲突概率低的场景
- 对系统性能要求较高的业务

### 优点
- 高并发性能
- 无死锁风险
- 系统响应速度快

### 缺点
- 冲突时需要重试操作
- 可能导致某些事务长期无法完成（饥饿问题）
- 实现相对复杂

## 最佳实践

### 通用原则
- **最小化锁持有时间**：尽可能短时间地持有锁，以减少竞争
- **细粒度锁定**：在最细粒度级别应用锁，例如行级锁而不是表级锁
- **重试机制**：为因冲突而失败的事务实现重试逻辑

### 选择建议
- **悲观锁**：更适合数据完整性要求高，但可能影响性能
- **乐观锁**：更适合追求效率和性能的场景

## 实际应用示例

### 悲观锁示例
```sql
-- 开始事务
BEGIN TRANSACTION;

-- 悲观锁：锁定行
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- 执行业务逻辑
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 提交事务
COMMIT;
```

### 乐观锁示例
```sql
-- 读取数据和版本号
SELECT id, balance, version FROM accounts WHERE id = 1;

-- 更新时检查版本号
UPDATE accounts 
SET balance = balance - 100, version = version + 1 
WHERE id = 1 AND version = @original_version;

-- 检查更新是否成功，如果失败则重试
```

## 性能对比

| 特性 | 悲观锁 | 乐观锁 |
|------|--------|--------|
| 并发性能 | 较低 | 较高 |
| 数据一致性 | 强一致性 | 最终一致性 |
| 死锁风险 | 存在 | 无 |
| 实现复杂度 | 简单 | 相对复杂 |
| 适用场景 | 写多读少 | 读多写少 |

## 总结

悲观锁和乐观锁各有优劣，选择哪种锁机制取决于具体的应用场景：

- **高并发读取场景**：优先选择乐观锁
- **频繁写入场景**：考虑使用悲观锁
- **混合场景**：可以根据不同的业务操作选择不同的锁策略

在实际项目中，往往需要根据具体的业务需求和性能要求来权衡选择，有时甚至需要在同一个系统中混合使用两种锁机制。
