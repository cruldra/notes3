编写自定义插件以扩展 OpenCode。

插件允许您通过挂钩各种事件和自定义行为来扩展 OpenCode。您可以创建插件来添加新功能、集成外部服务或修改 OpenCode 的默认行为。

有关示例，请查看社区创建的插件。

---

## [使用插件](#use-a-plugin)

有两种加载插件的方法。

---

### [从本地文件](#from-local-files)

将 JavaScript 或 TypeScript 文件放置在插件目录中。

* `.opencode/plugin/` - 项目级插件
* `~/.config/opencode/plugin/` - 全局插件

这些目录中的文件在启动时会自动加载。

---

### [从 npm](#from-npm)

在配置文件中指定 npm 包。

opencode.json

```json
{
  "$schema": "https://opencode.ai/config.json",
  "plugin": ["opencode-helicone-session", "opencode-wakatime", "@my-org/custom-plugin"]
}
```

支持常规和作用域 npm 包。

在生态系统中浏览可用的插件。

---

### [插件如何安装](#how-plugins-are-installed)

**npm 插件** 在启动时使用 Bun 自动安装。包及其依赖项缓存在 `~/.cache/opencode/node_modules/` 中。

**本地插件** 直接从插件目录加载。要使用外部包，您必须在配置目录中创建一个 `package.json`（参见依赖项部分），或者将插件发布到 npm 并将其添加到您的配置中。

---

### [加载顺序](#load-order)

插件从所有来源加载，所有钩子按顺序运行。加载顺序为：

1. 全局配置 (`~/.config/opencode/opencode.json`)
2. 项目配置 (`opencode.json`)
3. 全局插件目录 (`~/.config/opencode/plugin/`)
4. 项目插件目录 (`.opencode/plugin/`)

具有相同名称和版本的重复 npm 包仅加载一次。但是，具有相似名称的本地插件和 npm 插件都会被单独加载。

---

## [创建插件](#create-a-plugin)

插件是一个 **JavaScript/TypeScript 模块**，它导出一个或多个插件函数。每个函数接收一个上下文对象并返回一个钩子对象。

---

### [依赖项](#dependencies)

本地插件和自定义工具可以使用外部 npm 包。在您的配置目录中添加一个包含所需依赖项的 `package.json`。

.opencode/package.json

```json
{
  "dependencies": {
    "shescape": "^2.1.0"
  }
}
```

OpenCode 在启动时运行 `bun install` 来安装这些依赖。您的插件和工具随后可以导入它们。

.opencode/plugin/my-plugin.ts

```typescript
import { escape } from "shescape"

export const MyPlugin = async (ctx) => {
  return {
    "tool.execute.before": async (input, output) => {
      if (input.tool === "bash") {
        output.args.command = escape(output.args.command)
      }
    },
  }
}
```

---

### [基本结构](#basic-structure)

.opencode/plugin/example.js

```javascript
export const MyPlugin = async ({ project, client, $, directory, worktree }) => {
  console.log("Plugin initialized!")
  
  return {
    // Hook implementations go here
  }
}
```

插件函数接收：

* `project`: 当前项目信息。
* `directory`: 当前工作目录。
* `worktree`: git 工作树路径。
* `client`: 用于与 AI 交互的 opencode SDK 客户端。
* `$`: Bun 的 [shell API](https://bun.com/docs/runtime/shell)，用于执行命令。

---

### [TypeScript 支持](#typescript-support)

对于 TypeScript 插件，您可以从插件包导入类型：

my-plugin.ts

```typescript
import type { Plugin } from "@opencode-ai/plugin"

export const MyPlugin: Plugin = async ({ project, client, $, directory, worktree }) => {
  return {
    // Type-safe hook implementations
  }
}
```

---

### [事件](#events)

插件可以订阅事件，如下面的示例部分所示。以下是可用事件的列表。

#### [命令事件](#command-events)

* `command.executed`

#### [文件事件](#file-events)

* `file.edited`
* `file.watcher.updated`

#### [安装事件](#installation-events)

* `installation.updated`

#### [LSP 事件](#lsp-events)

* `lsp.client.diagnostics`
* `lsp.updated`

#### [消息事件](#message-events)

* `message.part.removed`
* `message.part.updated`
* `message.removed`
* `message.updated`

#### [权限事件](#permission-events)

* `permission.replied`
* `permission.updated`

#### [服务器事件](#server-events)

* `server.connected`

#### [会话事件](#session-events)

* `session.created`
* `session.compacted`
* `session.deleted`
* `session.diff`
* `session.error`
* `session.idle`
* `session.status`
* `session.updated`

#### [Todo 事件](#todo-events)

* `todo.updated`

#### [工具事件](#tool-events)

* `tool.execute.after`
* `tool.execute.before`

#### [TUI 事件](#tui-events)

* `tui.prompt.append`
* `tui.command.execute`
* `tui.toast.show`

---

## [示例](#examples)

这里有一些您可以用来扩展 opencode 的插件示例。

---

### [发送通知](#send-notifications)

当发生特定事件时发送通知：

.opencode/plugin/notification.js

```javascript
export const NotificationPlugin = async ({ project, client, $, directory, worktree }) => {
  return {
    event: async ({ event }) => {
      // Send notification on session completion
      if (event.type === "session.idle") {
        await $`osascript -e 'display notification "Session completed!" with title "opencode"'`
      }
    },
  }
}
```

我们使用 `osascript` 在 macOS 上运行 AppleScript。在这里，我们使用它来发送通知。

**注意**

如果您使用的是 OpenCode 桌面应用程序，当响应准备就绪或会话出错时，它可以自动发送系统通知。

---

### [.env 保护](#env-protection)

防止 opencode 读取 `.env` 文件：

.opencode/plugin/env-protection.js

```javascript
export const EnvProtection = async ({ project, client, $, directory, worktree }) => {
  return {
    "tool.execute.before": async (input, output) => {
      if (input.tool === "read" && output.args.filePath.includes(".env")) {
        throw new Error("Do not read .env files")
      }
    },
  }
}
```

---

### [自定义工具](#custom-tools)

插件还可以向 opencode 添加自定义工具：

.opencode/plugin/custom-tools.ts

```typescript
import { type Plugin, tool } from "@opencode-ai/plugin"

export const CustomToolsPlugin: Plugin = async (ctx) => {
  return {
    tool: {
      mytool: tool({
        description: "This is a custom tool",
        args: {
          foo: tool.schema.string(),
        },
        async execute(args, ctx) {
          return `Hello ${args.foo}!`
        },
      }),
    },
  }
}
```

`tool` 辅助函数创建一个 opencode 可以调用的自定义工具。它接受一个 Zod 模式函数并返回一个包含以下内容的工具定义：

* `description`: 工具的作用
* `args`: 工具参数的 Zod 模式
* `execute`: 工具被调用时运行的函数

您的自定义工具将与内置工具一起在 opencode 中可用。

---

### [日志记录](#logging)

使用 `client.app.log()` 代替 `console.log` 进行结构化日志记录：

.opencode/plugin/my-plugin.ts

```typescript
export const MyPlugin = async ({ client }) => {
  await client.app.log({
    service: "my-plugin",
    level: "info",
    message: "Plugin initialized",
    extra: { foo: "bar" },
  })
}
```

级别：`debug`、`info`、`warn`、`error`。有关详细信息，请参阅 [SDK 文档](https://opencode.ai/docs/sdk)。

---

### [压缩钩子](#compaction-hooks)

自定义会话压缩时包含的上下文：

.opencode/plugin/compaction.ts

```typescript
import type { Plugin } from "@opencode-ai/plugin"

export const CompactionPlugin: Plugin = async (ctx) => {
  return {
    "experimental.session.compacting": async (input, output) => {
      // Inject additional context into the compaction prompt
      output.context.push(`
        ## Custom Context
        Include any state that should persist across compaction:
        - Current task status
        - Important decisions made
        - Files being actively worked on
      `)
    },
  }
}
```

`experimental.session.compacting` 钩子在 LLM 生成延续摘要之前触发。使用它来注入默认压缩提示可能会遗漏的特定领域上下文。

您还可以通过设置 `output.prompt` 完全替换压缩提示：

.opencode/plugin/custom-compaction.ts

```typescript
import type { Plugin } from "@opencode-ai/plugin"

export const CustomCompactionPlugin: Plugin = async (ctx) => {
  return {
    "experimental.session.compacting": async (input, output) => {
      // Replace the entire compaction prompt
      output.prompt = `
        You are generating a continuation prompt for a multi-agent swarm session.
        Summarize:
        1. The current task and its status
        2. Which files are being modified and by whom
        3. Any blockers or dependencies between agents
        4. The next steps to complete the work
        Format as a structured prompt that a new agent can use to resume work.
      `
    },
  }
}
```

当设置了 `output.prompt` 时，它将完全替换默认的压缩提示。在这种情况下，`output.context` 数组将被忽略。
