# 自定义命令

自定义命令允许您将喜欢或最常用的提示保存为 Gemini CLI 中的个人快捷方式，以便重复使用。您可以创建特定于单个项目的命令，也可以创建在所有项目中全局可用的命令，从而简化您的工作流程并确保一致性。

## 文件位置和优先级

Gemini CLI 从两个位置发现命令，并按特定顺序加载：

1.  **用户命令（全局）：** 位于 `~/.gemini/commands/`。这些命令在您正在处理的任何项目中都可用。
2.  **项目命令（本地）：** 位于 `<your-project-root>/.gemini/commands/`。这些命令特定于当前项目，可以提交到版本控制以与您的团队共享。

如果项目目录中的命令与用户目录中的命令同名，则**始终使用项目命令**。这允许项目使用特定于项目的版本覆盖全局命令。

## 命名和命名空间

命令的名称由其相对于 `commands` 目录的文件路径决定。子目录用于创建命名空间命令，路径分隔符（`/` 或 `\`）被转换为冒号（`:`）。

-   `~/.gemini/commands/test.toml` 处的文件成为命令 `/test`。
-   `<project>/.gemini/commands/git/commit.toml` 处的文件成为命名空间命令 `/git:commit`。

## TOML 文件格式 (v1)

您的命令定义文件必须以 TOML 格式编写，并使用 `.toml` 文件扩展名。

### 必填字段

-   `prompt` (字符串)：执行命令时将发送给 Gemini 模型的提示。这可以是单行或多行字符串。

### 可选字段

-   `description` (字符串)：对命令功能的简短单行描述。此文本将显示在 `/help` 菜单中您的命令旁边。**如果您省略此字段，将从文件名生成通用描述。**

## 参数处理

自定义命令支持两种强大的参数处理方法。CLI 会根据命令 `prompt` 的内容自动选择正确的方法。

### 1. 使用 `{{args}}` 进行上下文感知注入

如果您的 `prompt` 包含特殊占位符 `{{args}}`，CLI 将用用户在命令名称后键入的文本替换该占位符。

此注入的行为取决于其使用位置：

**A. 原始注入（shell 命令之外）**

当在提示的主体中使用时，参数会按用户键入的方式精确注入。

**示例 (`git/fix.toml`)：**

```toml
# 调用方式： /git:fix "Button is misaligned"

description = "为给定问题生成修复方案。"
prompt = "请为此处描述的问题提供代码修复：{{args}}。"
```

模型收到：
`请为此处描述的问题提供代码修复："Button is misaligned"。`

**B. 在 shell 命令中使用参数（在 `!{...}` 块内部）**

当您在 shell 注入块 (`!{...}`) 内部使用 `{{args}}` 时，参数会在替换前自动**进行 shell 转义**。这允许您安全地将参数传递给 shell 命令，确保生成的命令语法正确且安全，同时防止命令注入漏洞。

**示例 (`/grep-code.toml`)：**

```toml
prompt = """
请总结模式 `{{args}}` 的查找结果。

搜索结果：
!{grep -r {{args}} .}
"""
```

当您运行 `/grep-code It\'s complicated` 时：

1.  CLI 看到 `{{args}}` 在外部和 `!{...}` 内部都被使用。
2.  外部：第一个 `{{args}}` 被原始替换为 `It\'s complicated`。
3.  内部：第二个 `{{args}}` 被替换为转义版本（例如，在 Linux 上为：`"It\'s complicated"`）。
4.  执行的命令是 `grep -r "It\'s complicated" .`。
5.  CLI 会提示您在执行前确认此精确、安全的命令。
6.  发送最终提示。

### 2. 默认参数处理

如果您的 `prompt` **不**包含特殊占位符 `{{args}}`，CLI 会使用默认行为来处理参数。

如果您为命令提供参数（例如，`/mycommand arg1`），CLI 会将您键入的完整命令附加到提示的末尾，并用两个换行符分隔。这使得模型能够同时看到原始指令和您刚刚提供的特定参数。

如果您**不**提供任何参数（例如，`/mycommand`），则提示会按原样发送给模型，没有任何附加内容。

**示例 (`changelog.toml`)：**

此示例展示了如何通过为模型定义角色、解释在哪里找到用户输入以及指定预期的格式和行为来创建健壮的命令。

```toml
# 在： <project>/.gemini/commands/changelog.toml
# 调用方式： /changelog 1.2.0 added "Support for default argument parsing."

description = "向项目的 CHANGELOG.md 文件添加新条目。"
prompt = """
# 任务：更新 Changelog

您是此软件项目的专业维护者。用户已调用命令以向变更日志添加新条目。

**用户提供的原始命令将附加在您的指令下方。**

您的任务是解析用户输入中的 `<version>`、`<change_type>` 和 `<message>`，并使用 `write_file` 工具正确更新 `CHANGELOG.md` 文件。

## 预期格式
命令遵循以下格式：`/changelog <version> <type> <message>`
- `<type>` 必须是以下之一："added", "changed", "fixed", "removed"。

## 行为
1. 读取 `CHANGELOG.md` 文件。
2. 找到指定 `<version>` 的部分。
3. 在正确的 `<type>` 标题下添加 `<message>`。
4. 如果版本或类型部分不存在，则创建它。
5. 严格遵守“保持变更日志”格式。
"""
```

当您运行 `/changelog 1.2.0 added "New feature"` 时，发送给模型的最终文本将是原始提示，后跟两个换行符以及您键入的命令。

### 3. 使用 `!{...}` 执行 shell 命令

您可以通过直接在 `prompt` 中执行 shell 命令并注入其输出来使您的命令具有动态性。这非常适合从本地环境收集上下文，例如读取文件内容或检查 Git 状态。

当自定义命令尝试执行 shell 命令时，Gemini CLI 现在会在执行前提示您确认。这是一项安全措施，旨在确保只执行预期的命令。

**工作原理：**

1.  **注入命令：** 使用 `!{...}` 语法。
2.  **参数替换：** 如果块内存在 `{{args}}`，它将自动进行 shell 转义（参见上面的"使用 `{{args}}` 进行上下文感知注入"部分）。
3.  **健壮的解析：** 解析器正确处理包含嵌套大括号的复杂 shell 命令，例如 JSON 有效负载。**注意：** `!{...}` 内部的内容必须具有平衡的大括号（`{` 和 `}`）。如果您需要执行包含不平衡大括号的命令，请考虑将其包装在外部脚本文件中，并在 `!{...}` 块内调用该脚本。
4.  **安全检查和确认：** CLI 对最终解析的命令（在参数转义和替换后）执行安全检查。将出现一个对话框，显示要执行的精确命令。
5.  **执行和错误报告：** 命令被执行。如果命令失败，注入到提示中的输出将包含错误消息（stderr），后跟一行状态信息，例如 `[Shell command exited with code 1]`。这有助于模型理解失败的上下文。

**示例 (`git/commit.toml`)：**

此命令获取暂存的 git diff 并使用它来要求模型编写提交消息。

````toml
# 在： <project>/.gemini/commands/git/commit.toml
# 调用方式： /git:commit

description = "根据暂存的更改生成 Git 提交消息。"

# 提示使用 !{...} 执行命令并注入其输出。
prompt = """
请根据以下 git diff 生成一个 Conventional Commit 消息：

```diff
!{git diff --staged}
```

"""

````

当您运行 `/git:commit` 时，CLI 首先执行 `git diff --staged`，然后将 `!{git diff --staged}` 替换为该命令的输出，然后再将最终的完整提示发送给模型。

### 4. 使用 `@{...}` 注入文件内容

您可以使用 `@{...}` 语法将文件内容或目录列表直接嵌入到提示中。这对于创建操作特定文件的命令非常有用。

**工作原理：**

-   **文件注入**：`@{path/to/file.txt}` 将被 `file.txt` 的内容替换。
-   **多模态支持**：如果路径指向支持的图像（例如 PNG、JPEG）、PDF、音频或视频文件，它将正确编码并作为多模态输入注入。其他二进制文件将被优雅处理并跳过。
-   **目录列表**：`@{path/to/dir}` 将被遍历，并且目录中以及所有子目录中的每个文件都将插入到提示中。这会遵守 `.gitignore` 和 `.geminiignore`（如果启用）。
-   **工作区感知**：命令在当前目录和任何其他工作区目录中搜索路径。如果绝对路径在工作区内，则允许使用。
-   **处理顺序**：文件内容注入 `@{...}` 在 shell 命令 (`!{...}`) 和参数替换 (`{{args}}`) **之前**处理。
-   **解析**：解析器要求 `@{...}` 内部的内容（路径）具有平衡的大括号（`{` 和 `}`）。

**示例 (`review.toml`)：**

此命令注入 _固定_ 最佳实践文件 (`docs/best-practices.md`) 的内容，并使用用户参数为审阅提供上下文。

```toml
# 在： <project>/.gemini/commands/review.toml
# 调用方式： /review FileCommandLoader.ts

description = "使用最佳实践指南审阅提供的上下文。"
prompt = """
您是一名专业的代码审阅者。

您的任务是审阅 {{args}}。

在提供审阅时，请使用以下最佳实践：

@{docs/best-practices.md}
"""
```

当您运行 `/review FileCommandLoader.ts` 时，`@{docs/best-practices.md}` 占位符将被该文件的内容替换，并且 `{{args}}` 将被您提供的文本替换，然后将最终提示发送给模型。

---

## 示例：一个“纯函数”重构命令

让我们创建一个全局命令，要求模型重构一段代码。

**1. 创建文件和目录：**

首先，确保用户命令目录存在，然后创建一个 `refactor` 子目录用于组织，以及最终的 TOML 文件。

```bash
mkdir -p ~/.gemini/commands/refactor
touch ~/.gemini/commands/refactor/pure.toml
```

**2. 将内容添加到文件：**

在您的编辑器中打开 `~/.gemini/commands/refactor/pure.toml` 并添加以下内容。我们包含可选的 `description` 以获得最佳实践。

```toml
# 在： ~/.gemini/commands/refactor/pure.toml
# 此命令将通过以下方式调用： /refactor:pure

description = "要求模型将当前上下文重构为纯函数。"

prompt = """
请分析我在当前上下文中提供的代码。
将其重构为纯函数。

您的响应应包括：
1. 重构后的纯函数代码块。
2. 对您所做的关键更改及其为何有助于纯度的简要解释。
"""
```

**3. 运行命令：**

就是这样！您现在可以在 CLI 中运行您的命令。首先，您可以将文件添加到上下文，然后调用您的命令：

```
> @my-messy-function.js
> /refactor:pure
```

Gemini CLI 将执行您在 TOML 文件中定义的多行提示。
