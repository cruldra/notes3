---
sidebar_position: 5
---

现在是时候制作玩家必须躲避的敌人了。它们的行为不会很复杂：小怪将从屏幕边缘随机生成，选择一个随机方向，并直线移动。

我们将创建一个 `Mob` (小怪) 场景，然后我们可以对其进行 **实例化 (instance)**，以在游戏中创建任意数量的独立小怪。

## 节点设置 (Node setup)

点击顶部菜单的 **场景 > 新建场景**，并添加以下节点：

*   [RigidBody2D](https://docs.godotengine.org/en/stable/classes/class_rigidbody2d.html) (命名为 `Mob`)
    *   [AnimatedSprite2D](https://docs.godotengine.org/en/stable/classes/class_animatedsprite2d.html)
    *   [CollisionShape2D](https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html)
    *   [VisibleOnScreenNotifier2D](https://docs.godotengine.org/en/stable/classes/class_visibleonscreennotifier2d.html)

别忘了设置子节点使其无法被选中，就像你对玩家场景所做的那样。操作方法是在场景树面板中选中父节点 (`RigidBody2D`)，然后使用 2D 编辑器顶部的 “分组” 按钮（或按 **Ctrl + G**）。

选中 `Mob` 节点，并在检查器的 **RigidBody2D** 部分将 `Gravity Scale` (重力缩放) 属性设置为 `0`。这将防止小怪向下掉落。

此外，在 **RigidBody2D** 部分下方的 [CollisionObject2D](https://docs.godotengine.org/en/stable/classes/class_collisionobject2d.html) 部分，展开 **Collision** 组，并取消勾选 `Mask` 属性中的 `1`。这将确保小怪之间不会相互碰撞。

![Set Collision Mask](https://docs.godotengine.org/en/stable/_images/set_collision_mask.webp)

像设置玩家那样设置 [AnimatedSprite2D](https://docs.godotengine.org/en/stable/classes/class_animatedsprite2d.html)。这次，我们有 3 个动画：`fly` (飞)、`swim` (游) 和 `walk` (走)。`art` 文件夹中每个动画都有两张图像。

必须为每个单独的动画设置 `Animation Speed` (动画速度) 属性。将所有 3 个动画的速度都调整为 `3`。

![Mob Animations](https://docs.godotengine.org/en/stable/_images/mob_animations.webp)

你可以使用 `Animation Speed` 输入字段右侧的 “播放动画” 按钮来预览动画。

我们将随机选择其中一个动画，以便小怪具有一定的多样性。

和玩家图像一样，这些小怪图像也需要缩小。将 `AnimatedSprite2D` 的 `Scale` 属性设置为 `(0.75, 0.75)`。

和在 `Player` 场景中一样，添加一个 `CapsuleShape2D` 作为碰撞形状。为了使形状与图像对齐，你需要将 `Rotation` (旋转) 属性设置为 `90`（在检查器的 “Transform” 下）。

保存场景。

## 敌人脚本 (Enemy script)

像这样为 `Mob` 添加一个脚本：

```gdscript
extends RigidBody2D
```

```csharp
using Godot;

public partial class Mob : RigidBody2D
{
    // 别忘了重新构建项目。
}
```

现在让我们看看脚本的其余部分。在 `_ready()` 中，我们播放动画并从三种动画类型中随机选择一种：

```gdscript
func _ready():
	var mob_types = Array($AnimatedSprite2D.sprite_frames.get_animation_names())
	$AnimatedSprite2D.animation = mob_types.pick_random()
	$AnimatedSprite2D.play()
```

```csharp
public override void _Ready()
{
    var animatedSprite2D = GetNode<AnimatedSprite2D>("AnimatedSprite2D");
    string[] mobTypes = animatedSprite2D.SpriteFrames.GetAnimationNames();
    animatedSprite2D.Play(mobTypes[GD.Randi() % mobTypes.Length]);
}
```

首先，我们从 `AnimatedSprite2D` 的 `sprite_frames` 属性中获取动画名称列表。这将返回一个包含所有三个动画名称的数组：`["walk", "swim", "fly"]`。

在 GDScript 代码中，我们使用 `Array.pick_random()` 方法随机选择其中一个动画名称。而在 C# 代码中，我们选取 `0` 到 `2` 之间的随机数来从列表中选择一个名称（数组索引从 0 开始）。表达式 `GD.Randi() % n` 会选择 `0` 到 `n-1` 之间的随机整数。

最后，我们调用 `play()` 开始播放选定的动画。

最后一步是让小怪在离开屏幕时删除自己。将 `VisibleOnScreenNotifier2D` 节点的 `screen_exited()` 信号连接到 `Mob` 并添加以下代码：

```gdscript
func _on_visible_on_screen_notifier_2d_screen_exited():
	queue_free()
```

```csharp
// 我们还在编辑器的连接窗口中以 PascalCase 指定了此函数名称。
private void OnVisibleOnScreenNotifier2DScreenExited()
{
    QueueFree();
}
```

`queue_free()` 函数会在当前帧结束时 “释放” 或删除该节点。

至此，小怪场景就完成了。

随着玩家和敌人的就绪，在下一部分中，我们将它们整合到一个新场景中。我们将让敌人在游戏板周围随机生成并向前移动，将我们的项目变成一个可玩的游戏。
