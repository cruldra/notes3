"use strict";(self.webpackChunknotes_3=self.webpackChunknotes_3||[]).push([[2083],{52827:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Rust/actix-web/\u5feb\u901f\u5f00\u59cb","title":"\u5feb\u901f\u5f00\u59cb","description":"\u6dfb\u52a0\u4f9d\u8d56","source":"@site/docs/Rust/actix-web/\u5feb\u901f\u5f00\u59cb.mdx","sourceDirName":"Rust/actix-web","slug":"/Rust/actix-web/\u5feb\u901f\u5f00\u59cb","permalink":"/notes3/docs/Rust/actix-web/\u5feb\u901f\u5f00\u59cb","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Rust/actix-web/\u5feb\u901f\u5f00\u59cb.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"rust","previous":{"title":"Actix-web","permalink":"/notes3/docs/category/actix-web"},"next":{"title":"\u7ed3\u6784\u4f53","permalink":"/notes3/docs/Rust/\u7ed3\u6784\u4f53"}}');var s=r(23420),i=r(54213);const a={},o=void 0,l={},c=[{value:"\u6dfb\u52a0\u4f9d\u8d56",id:"\u6dfb\u52a0\u4f9d\u8d56",level:2},{value:"\u793a\u4f8b",id:"\u793a\u4f8b",level:2}];function d(e){const n={code:"code",h2:"h2",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"\u6dfb\u52a0\u4f9d\u8d56",children:"\u6dfb\u52a0\u4f9d\u8d56"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\r\nactix-web = "4.10.2"\r\nactix-files = "0.6.5"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"\u793a\u4f8b",children:"\u793a\u4f8b"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use actix_web::{web, App, HttpResponse, HttpServer, Responder, get, post};\r\nuse actix_files;\r\nuse serde::{Deserialize, Serialize};\r\nuse std::sync::{Arc, Mutex};\r\nuse std::thread;\r\nuse std::fs;\r\nuse tauri::Emitter;\r\nuse tokio::runtime::Runtime;\r\nuse config::{Config, ConfigError, Environment, File};\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct Settings {\r\n    // \u5fc5\u987b\u5728\u914d\u7f6e\u4e2d\u6307\u5b9a\uff0c\u6ca1\u6709\u9ed8\u8ba4\u503c\r\n    pub conversation_list_dir: String,\r\n    pub get_latest_msg_requests_dir: String,\r\n}\r\n\r\nimpl Settings {\r\n    pub fn load() -> Result<Self, ConfigError> {\r\n        // Create configuration builder\r\n        let config_builder = Config::builder()\r\n            // Add in settings from the config file if it exists\r\n            // Try multiple possible locations for the config file\r\n            .add_source(File::with_name("config.yaml").required(false))\r\n            // Add in settings from the environment\r\n            // Prefix variables with "APP_" to avoid conflicts\r\n            // For example, APP_CONVERSATION_LIST_DIR=path/to/dir\r\n            .add_source(Environment::with_prefix("APP").separator("_"));\r\n\r\n        // Build the configuration\r\n        let config = config_builder.build()?;\r\n\r\n        // Deserialize the configuration into our Settings struct\r\n        config.try_deserialize()\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct Conversation {\r\n    pub name: String,\r\n    pub avatar: String,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct ConversationList(Vec<Conversation>);\r\n\r\nimpl ConversationList {\r\n    pub fn new() -> Self {\r\n        ConversationList(Vec::new())\r\n    }\r\n\r\n    pub fn add(&mut self, conversation: Conversation) {\r\n        self.0.push(conversation);\r\n    }\r\n\r\n    pub fn as_vec(&self) -> &Vec<Conversation> {\r\n        &self.0\r\n    }\r\n\r\n    pub fn len(&self) -> usize {\r\n        self.0.len()\r\n    }\r\n}\r\n\r\n// Message request structure\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct MessageRequest {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub msg: String,\r\n}\r\n\r\n// Shared state for the HTTP server\r\npub struct AppState {\r\n    pub app_handle: Arc<Mutex<Option<tauri::AppHandle>>>,\r\n    pub settings: Settings,\r\n}\r\n\r\n// HTTP endpoint to get conversation list\r\n#[get("/api/conversation-list")]\r\nasync fn receive_conversation_list(\r\n    data: web::Data<AppState>,\r\n) -> impl Responder {\r\n    println!("Scanning conversation list from directory");\r\n\r\n    // Get the directory from app state\r\n    let dir_path = &data.settings.conversation_list_dir;\r\n\r\n    // Create a new conversation list\r\n    let mut conversation_list = ConversationList::new();\r\n\r\n    // Scan the directory\r\n    match fs::read_dir(dir_path) {\r\n        Ok(entries) => {\r\n            for entry in entries {\r\n                if let Ok(entry) = entry {\r\n                    // Get the file name\r\n                    if let Some(file_name) = entry.file_name().to_str() {\r\n                        // Remove file extension from the name\r\n                        let name_without_extension = if let Some(dot_pos) = file_name.rfind(\'.\') {\r\n                            &file_name[0..dot_pos]\r\n                        } else {\r\n                            file_name // If no extension found, use the original name\r\n                        };\r\n\r\n                        // Create a conversation object\r\n                        let conversation = Conversation {\r\n                            name: name_without_extension.to_string(),\r\n                            avatar: format!("http://127.0.0.1:3030/imgs/{}", file_name),\r\n                        };\r\n\r\n                        // Print before adding to the list\r\n                        println!("Added conversation: name={} (original filename: {})", conversation.name, file_name);\r\n\r\n                        // Add to the list\r\n                        conversation_list.add(conversation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            println!("Found {} conversations", conversation_list.len());\r\n\r\n            // Emit event to frontend\r\n            if let Some(app_handle) = data.app_handle.lock().unwrap().as_ref() {\r\n                // Use the emit method to send the event to the frontend\r\n                let _ = app_handle.emit("conversation_list_received", conversation_list.as_vec().clone());\r\n            }\r\n\r\n            HttpResponse::Ok().json(serde_json::json!({\r\n                "status": "success",\r\n                "count": conversation_list.len()\r\n            }))\r\n        },\r\n        Err(e) => {\r\n            println!("Error reading directory: {}", e);\r\n            HttpResponse::InternalServerError().json(serde_json::json!({\r\n                "status": "error",\r\n                "message": format!("Failed to read directory: {}", e)\r\n            }))\r\n        }\r\n    }\r\n}\r\n\r\n// HTTP endpoint to receive latest message\r\n#[post("/api/latest-message")]\r\nasync fn receive_latest_message(\r\n    data: web::Data<AppState>,\r\n    message: web::Json<MessageRequest>,\r\n) -> impl Responder {\r\n    println!("Received latest message for conversation ID: {}", message.name);\r\n    println!("Message content: {}", message.msg);\r\n    println!("Message ID: {}", message.id);\r\n\r\n    // Emit event to frontend\r\n    if let Some(app_handle) = data.app_handle.lock().unwrap().as_ref() {\r\n        // Use the emit method to send the event to the frontend\r\n        let _ = app_handle.emit("latest_message_received", message.0);\r\n        println!("Emitted latest_message_received event");\r\n    }\r\n\r\n    HttpResponse::Ok().json(serde_json::json!({\r\n        "status": "success"\r\n    }))\r\n}\r\n\r\n// Start the HTTP server\r\npub fn start_http_server(app_handle: tauri::AppHandle) {\r\n    // Clone the app handle to move into the thread\r\n    let app_handle_clone = app_handle.clone();\r\n\r\n    // Load settings at application startup\r\n    let settings = match Settings::load() {\r\n        Ok(settings) => {\r\n            println!("Loaded configuration: conversation_list_dir={}", settings.conversation_list_dir);\r\n            settings\r\n        },\r\n        Err(e) => {\r\n            eprintln!("\u9519\u8bef: \u65e0\u6cd5\u52a0\u8f7d\u914d\u7f6e: {}", e);\r\n            eprintln!("\u8bf7\u786e\u4fdd\u5728\u914d\u7f6e\u6587\u4ef6\u4e2d\u8bbe\u7f6e\u4e86 conversation_list_dir \u8def\u5f84");\r\n            eprintln!("\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u8bbe\u7f6e:");\r\n            eprintln!("1. \u5728 client/config/default.yaml \u6587\u4ef6\u4e2d\u8bbe\u7f6e conversation_list_dir");\r\n            eprintln!("2. \u8bbe\u7f6e\u73af\u5883\u53d8\u91cf APP_CONVERSATION_LIST_DIR");\r\n            panic!("\u7f3a\u5c11\u5fc5\u8981\u7684\u914d\u7f6e: conversation_list_dir");\r\n        }\r\n    };\r\n\r\n    // Verify that the directory exists\r\n    if !std::path::Path::new(&settings.conversation_list_dir).exists() {\r\n        println!("Warning: Directory \'{}\' does not exist. Creating it...", settings.conversation_list_dir);\r\n        // Try to create the directory\r\n        match std::fs::create_dir_all(&settings.conversation_list_dir) {\r\n            Ok(_) => println!("Directory created successfully."),\r\n            Err(e) => println!("Failed to create directory: {}", e),\r\n        }\r\n    }\r\n\r\n    // Start the HTTP server in a separate thread\r\n    thread::spawn(move || {\r\n        // Create a tokio runtime\r\n        let rt = Runtime::new().unwrap();\r\n\r\n        // Run the HTTP server in the tokio runtime\r\n        rt.block_on(async {\r\n            // Create app state with settings\r\n            let app_state = web::Data::new(AppState {\r\n                app_handle: Arc::new(Mutex::new(Some(app_handle_clone))),\r\n                settings: settings.clone(),\r\n            });\r\n\r\n            HttpServer::new(move || {\r\n                App::new()\r\n                    .app_data(app_state.clone())\r\n                    .service(receive_conversation_list)\r\n                    .service(receive_latest_message)\r\n                    .service(actix_files::Files::new("/imgs", &settings.conversation_list_dir))\r\n            })\r\n            .bind("127.0.0.1:3030")\r\n            .unwrap()\r\n            .run()\r\n            .await\r\n            .unwrap();\r\n        });\r\n    });\r\n\r\n    println!("HTTP server started on http://127.0.0.1:3030");\r\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},54213:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(36672);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);